// ==UserScript==
// @name        GitHub Collapse Markdown
// @version     3.2.4
// @description üöÄ ÁÆÄÊ¥ÅÈ´òÊïàÁöÑGitHub MarkdownÊ†áÈ¢òÊäòÂè†ËÑöÊú¨ÔºöÊô∫ËÉΩÂµåÂ•óüß†+Âø´Êç∑ÈîÆ‚å®Ô∏è+ÁõÆÂΩïüìë+ÊêúÁ¥¢üîç+Áä∂ÊÄÅËÆ∞ÂøÜüíæ+ÁÆÄÁ∫¶GUIüîò
// @license     MIT
// @author      Xyea
// @namespace   https://github.com/XyeaOvO/GitHub-Collapse-Markdown
// @homepageURL https://github.com/XyeaOvO/GitHub-Collapse-Markdown
// @supportURL  https://github.com/XyeaOvO/GitHub-Collapse-Markdown/issues
// @match       https://github.com/*
// @match       https://gist.github.com/*
// @match       https://help.github.com/*
// @match       https://docs.github.com/*
// @run-at      document-idle
// @grant       GM_addStyle
// @grant       GM_getValue
// @grant       GM_setValue
// @grant       GM_registerMenuCommand
// @noframes
// @icon        https://github.githubassets.com/pinned-octocat.svg
// ==/UserScript==

(() => {
	"use strict";

	// ÈÖçÁΩÆÂ∏∏Èáè
	const CONFIG = {
		debug: GM_getValue("ghcm-debug-mode", false), // Ë∞ÉËØïÊ®°ÂºèÂºÄÂÖ≥
		colors: GM_getValue("ghcm-colors", [
			"#6778d0", "#ac9c3d", "#b94a73", "#56ae6c", "#9750a1", "#ba543d"
		]),
		animation: {
			duration: 200,
			easing: "cubic-bezier(0.4, 0, 0.2, 1)",
			maxAnimatedElements: GM_getValue("ghcm-performance-mode", false) ? 0 : 20, // Ê†πÊçÆÁî®Êà∑ËÆæÁΩÆ
			batchSize: 10 // ÊâπÈáèÂ§ÑÁêÜÂ§ßÂ∞è
		},
		selectors: {
			markdownContainers: [
				".markdown-body",
				".comment-body"
			],
			headers: ["H1", "H2", "H3", "H4", "H5", "H6"],
			excludeClicks: [".anchor", ".octicon-link", "a", "img"]
		},
		classes: {
			collapsed: "ghcm-collapsed",
			hidden: "ghcm-hidden",
			hiddenByParent: "ghcm-hidden-by-parent",
			noContent: "ghcm-no-content",
			tocContainer: "ghcm-toc-container",
			searchContainer: "ghcm-search-container",
			menuContainer: "ghcm-menu-container",
			menuButton: "ghcm-menu-button",
			bookmarked: "ghcm-bookmarked",
			activeHeading: "ghcm-active-heading",
			hoverHeading: "ghcm-hover-heading"
		},
		hotkeys: {
			enabled: GM_getValue("ghcm-hotkeys-enabled", true),
			toggleAll: "ctrl+shift+a", // ÂàáÊç¢ÊâÄÊúâÊäòÂè†
			collapseAll: "ctrl+shift+c", // ÊäòÂè†ÊâÄÊúâ
			expandAll: "ctrl+shift+e", // Â±ïÂºÄÊâÄÊúâ
			showToc: "ctrl+shift+l", // ÊòæÁ§∫ÁõÆÂΩï
			search: "ctrl+shift+f", // ÊêúÁ¥¢
			menu: "ctrl+shift+m", // ÊòæÁ§∫ËèúÂçï
			bookmark: GM_getValue('ghcm-hotkey-bookmark', 'ctrl+shift+b'),
			nextHeading: 'j',
			prevHeading: 'k',
			navEnabled: GM_getValue('ghcm-nav-enabled', false)
		},
		memory: {
			enabled: GM_getValue("ghcm-memory-enabled", true),
			key: "ghcm-page-states"
		},
		bookmarks: {
			key: 'ghcm-bookmarks'
		},
		ui: {
			showLevelNumber: GM_getValue('ghcm-show-level-number', true),
		arrowSize: GM_getValue('ghcm-arrow-size', '0.8em')
		},
		colorSchemes: {
			default: ["#6778d0", "#ac9c3d", "#b94a73", "#56ae6c", "#9750a1", "#ba543d"],
			pastel:  ["#7aa2f7", "#e6a23c", "#f48fb1", "#9ccc65", "#b39ddb", "#ffab91"],
			vibrant: ["#3b82f6", "#f59e0b", "#ef4444", "#10b981", "#8b5cf6", "#f97316"],
		mono:    ["#6b7280", "#6b7280", "#6b7280", "#6b7280", "#6b7280", "#6b7280"]
		}
	};

	const storedCustomColors = GM_getValue('ghcm-custom-colors', null);
	if (Array.isArray(storedCustomColors) && storedCustomColors.length) {
		CONFIG.colorSchemes.custom = storedCustomColors;
	}

	// Êó•ÂøóÊéßÂà∂ÂáΩÊï∞
	const Logger = {
		log: (...args) => {
			if (CONFIG.debug) {
				console.log(...args);
			}
		},
		warn: (...args) => {
			console.warn(...args);
		},
		error: (...args) => {
			console.error(...args);
		}
	};

	// GUIËèúÂçïÁÆ°ÁêÜÂô®
	class MenuManager {
		constructor(app) {
			this.app = app;
			this.isVisible = false;
			this.menuContainer = null;
			this.menuButton = null;
			this.init();
		}

		init() {
			this.createMenuButton();
			this.addMenuStyles();
			// Ê†πÊçÆÈ°µÈù¢ÊòØÂê¶Êúâ markdown ÂÆπÂô®ÊòæÁ§∫/ÈöêËóèÊåâÈíÆ
			this.updateButtonVisibility();
			['pjax:end','turbo:load','turbo:render','pageshow'].forEach(evt => {
				try { document.addEventListener(evt, () => this.updateButtonVisibility()); } catch {}
			});
		}

		addMenuStyles() {
			GM_addStyle(`
				/* ËèúÂçïÊåâÈíÆ */
				.${CONFIG.classes.menuButton} {
					position: fixed;
					bottom: 20px;
					right: 20px;
					width: 50px;
					height: 50px;
					background: #6b7280;
					border: none;
					border-radius: 50%;
					cursor: pointer;
					z-index: 9999;
					box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
					transition: all 0.2s ease;
					display: flex;
					align-items: center;
					justify-content: center;
					font-size: 18px;
					color: white;
					user-select: none;
				}

				.${CONFIG.classes.menuButton}:hover {
					background: #4b5563;
					transform: translateY(-1px);
					box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
				}

				.${CONFIG.classes.menuButton}:active {
					transform: translateY(0) scale(0.95);
				}

				.${CONFIG.classes.menuButton}.menu-open {
					background: #374151;
					transform: rotate(45deg);
				}

				/* ËèúÂçïÂÆπÂô® */
				.${CONFIG.classes.menuContainer} {
					position: fixed;
					bottom: 80px;
					right: 20px;
					width: 300px;
					background: rgba(255, 255, 255, 0.98);
					backdrop-filter: blur(10px);
					border: 1px solid #e5e7eb;
					border-radius: 12px;
					box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
					z-index: 9998;
					opacity: 0;
					transform: translateY(10px) scale(0.95);
					transition: all 0.25s ease;
					overflow: hidden;
					font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
				}

				.${CONFIG.classes.menuContainer}.show {
					opacity: 1;
					transform: translateY(0) scale(1);
				}

				/* ËèúÂçïÂ§¥ÈÉ® */
				.ghcm-menu-header {
					padding: 16px 20px 12px;
					background: #f9fafb;
					color: #374151;
					text-align: center;
					border-bottom: 1px solid #e5e7eb;
				}

				.ghcm-menu-title {
					font-size: 16px;
					font-weight: 600;
					margin: 0 0 4px;
				}

				.ghcm-menu-subtitle {
					font-size: 11px;
					opacity: 0.7;
					margin: 0;
				}

				/* ËèúÂçïÂÜÖÂÆπ */
				.ghcm-menu-content {
					padding: 0;
					max-height: 400px;
					overflow-y: auto;
				}

				/* ËèúÂçïÂàÜÁªÑ */
				.ghcm-menu-group {
					padding: 12px 0;
					border-bottom: 1px solid #f3f4f6;
				}

				.ghcm-menu-group:last-child {
					border-bottom: none;
				}

				.ghcm-menu-group-title {
					font-size: 10px;
					font-weight: 600;
					color: #9ca3af;
					text-transform: uppercase;
					letter-spacing: 0.5px;
					margin: 0 20px 8px;
				}

				/* ËèúÂçïÈ°π */
				.ghcm-menu-item {
					display: flex;
					align-items: center;
					padding: 10px 20px;
					cursor: pointer;
					transition: background-color 0.15s ease;
					color: #374151;
					text-decoration: none;
					font-size: 13px;
					line-height: 1.4;
				}

				.ghcm-menu-item:hover {
					background: #f3f4f6;
					color: #1f2937;
				}

				.ghcm-menu-item:active {
					background: #e5e7eb;
				}

				.ghcm-menu-item-icon {
					width: 20px;
					height: 20px;
					margin-right: 12px;
					display: flex;
					align-items: center;
					justify-content: center;
					font-size: 16px;
					flex-shrink: 0;
				}

				.ghcm-menu-item-text {
					flex: 1;
					font-weight: 500;
				}

				.ghcm-menu-item-shortcut {
					font-size: 10px;
					color: #9ca3af;
					background: #f3f4f6;
					padding: 2px 6px;
					border-radius: 3px;
					font-family: Monaco, 'Courier New', monospace;
				}

				.ghcm-menu-item-note {
					margin-left: auto;
					font-size: 11px;
					color: #9ca3af;
				}

				.ghcm-menu-item-badge {
					background: #6b7280;
					color: white;
					font-size: 10px;
					padding: 2px 6px;
					border-radius: 6px;
					font-weight: 500;
				}

				/* ÂàáÊç¢ÂºÄÂÖ≥ */
				.ghcm-menu-toggle {
					position: relative;
					width: 36px;
					height: 18px;
					background: #d1d5db;
					border-radius: 9px;
					transition: background 0.2s ease;
					cursor: pointer;
				}

				.ghcm-menu-toggle.active {
					background: #6b7280;
				}

				.ghcm-menu-toggle::after {
					content: '';
					position: absolute;
					top: 2px;
					left: 2px;
					width: 14px;
					height: 14px;
					background: white;
					border-radius: 50%;
					transition: transform 0.2s ease;
					box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
				}

				.ghcm-menu-toggle.active::after {
					transform: translateX(18px);
				}

				/* ÁªüËÆ°‰ø°ÊÅØ */
				.ghcm-menu-stats {
					padding: 12px 20px;
					background: #f9fafb;
					font-size: 11px;
					color: #6b7280;
					line-height: 1.5;
				}

				.ghcm-menu-stats-item {
					display: flex;
					justify-content: space-between;
					margin-bottom: 3px;
				}

				.ghcm-menu-stats-item:last-child {
					margin-bottom: 0;
				}

				.ghcm-menu-stats-value {
					font-weight: 600;
					color: #374151;
				}

				.ghcm-bookmark-list {
					padding: 6px 10px;
					max-height: 160px;
					overflow-y: auto;
				}

				.ghcm-bookmark-item {
					display: flex;
					align-items: center;
					justify-content: space-between;
				}

				.ghcm-bookmark-info {
					display: flex;
					flex: 1;
					align-items: center;
					gap: 6px;
				}

				.ghcm-bookmark-level {
					font-size: 10px;
					font-weight: 600;
					color: #6b7280;
				}

				.ghcm-bookmark-text {
					flex: 1;
					font-size: 12px;
					color: #374151;
					overflow: hidden;
					text-overflow: ellipsis;
					white-space: nowrap;
				}

				.ghcm-bookmark-remove {
					background: none;
					border: none;
					color: #9ca3af;
					cursor: pointer;
					padding: 4px;
					border-radius: 4px;
					font-size: 12px;
				}

				.ghcm-bookmark-remove:hover {
					background: rgba(148, 163, 184, 0.18);
					color: #4b5563;
				}

				.ghcm-bookmark-empty {
					padding: 6px 0;
					text-align: center;
					font-size: 12px;
					color: #9ca3af;
				}

				/* Ê∑±Ëâ≤‰∏ªÈ¢òÈÄÇÈÖç */
				@media (prefers-color-scheme: dark) {
					.${CONFIG.classes.menuContainer} {
						background: rgba(31, 41, 55, 0.98);
						border-color: #374151;
					}

					.ghcm-menu-header {
						background: #1f2937;
						color: #f9fafb;
						border-bottom-color: #374151;
					}

					.ghcm-menu-item {
						color: #e5e7eb;
					}

					.ghcm-menu-item:hover {
						background: #374151;
						color: #f9fafb;
					}

					.ghcm-menu-group {
						border-bottom-color: #374151;
					}

					.ghcm-menu-group-title {
						color: #9ca3af;
					}

					.ghcm-menu-item-shortcut {
						background: #374151;
						color: #9ca3af;
					}

					.ghcm-menu-stats {
						background: #1f2937;
						color: #9ca3af;
					}

					.ghcm-menu-stats-value {
						color: #e5e7eb;
					}

					.${CONFIG.classes.bookmarked} {
						background: rgba(202, 138, 4, 0.38);
					}

					.ghcm-bookmark-text {
						color: #e5e7eb;
					}

					.ghcm-bookmark-remove:hover {
						background: rgba(75, 85, 99, 0.35);
						color: #f3f4f6;
					}

					.${CONFIG.classes.hoverHeading} {
						background: rgba(75, 85, 99, 0.32);
					}
				}

				/* ÂìçÂ∫îÂºèËÆæËÆ° */
				@media (max-width: 480px) {
					.${CONFIG.classes.menuContainer} {
						right: 15px;
						width: calc(100vw - 30px);
						max-width: 320px;
					}

					.${CONFIG.classes.menuButton} {
						right: 15px;
						bottom: 15px;
					}
				}
			`);
		}

		createMenuButton() {
			this.menuButton = document.createElement('button');
			this.menuButton.className = CONFIG.classes.menuButton;
			this.menuButton.innerHTML = '‚öôÔ∏è';
			this.menuButton.title = 'GitHub Collapse Markdown ËÆæÁΩÆ';
			this.menuButton.setAttribute('aria-label', 'ÊâìÂºÄËÆæÁΩÆ');
			this.menuButton.setAttribute('aria-expanded', 'false');
			this.menuButton.setAttribute('aria-controls', 'ghcm-menu-panel');

			this.menuButton.addEventListener('click', (e) => {
				e.stopPropagation();
				this.toggle();
			});

			document.body.appendChild(this.menuButton);
		}

		shouldShowButton() {
			try {
				return DOMUtils.hasMarkdownHeadings();
			} catch {
				return true;
			}
		}

		updateButtonVisibility() {
			if (!this.menuButton) return;
			const visible = this.shouldShowButton();
			this.menuButton.style.display = visible ? 'flex' : 'none';
		}

		createMenuContainer() {
			const container = document.createElement('div');
			container.className = CONFIG.classes.menuContainer;
			container.id = 'ghcm-menu-panel';
			container.setAttribute('role', 'dialog');
			container.setAttribute('aria-modal', 'true');
			container.setAttribute('aria-label', 'Collapse Markdown ËÆæÁΩÆ');

			container.innerHTML = `
				<div class="ghcm-menu-header">
					<h3 class="ghcm-menu-title">üìù Collapse Markdown</h3>
					<p class="ghcm-menu-subtitle">Êô∫ËÉΩÊ†áÈ¢òÊäòÂè†Â∑•ÂÖ∑</p>
				</div>
				<div class="ghcm-menu-content">
					${this.generateMenuContent()}
				</div>
			`;

			this.setupMenuEvents(container);
			return container;
		}

		generateMenuContent() {
			const stats = this.getStatistics();

				return `
					<div class="ghcm-menu-stats">
						<div class="ghcm-menu-stats-item">
							<span>ÊÄªÊ†áÈ¢òÊï∞</span>
							<span class="ghcm-menu-stats-value" data-stat="total">${stats.total}</span>
						</div>
						<div class="ghcm-menu-stats-item">
							<span>Â∑≤ÊäòÂè†</span>
							<span class="ghcm-menu-stats-value" data-stat="collapsed">${stats.collapsed}</span>
						</div>
						<div class="ghcm-menu-stats-item">
							<span>ÂèØËßÅ</span>
							<span class="ghcm-menu-stats-value" data-stat="visible">${stats.visible}</span>
						</div>
					</div>

					<div class="ghcm-menu-group">
						<div class="ghcm-menu-group-title">Âø´ÈÄü‰π¶Á≠æ</div>
						<div class="ghcm-menu-item" data-action="bookmark-add">
							<div class="ghcm-menu-item-icon">‚≠ê</div>
							<div class="ghcm-menu-item-text">Êî∂ËóèÂΩìÂâçÊ†áÈ¢ò</div>
							<div class="ghcm-menu-item-shortcut">${CONFIG.hotkeys.bookmark}</div>
						</div>
						<div class="ghcm-menu-item" data-action="bookmark-clear">
							<div class="ghcm-menu-item-icon">üóÇÔ∏è</div>
							<div class="ghcm-menu-item-text">Ê∏ÖÁ©∫Êú¨È°µ‰π¶Á≠æ</div>
						</div>
						<div class="ghcm-bookmark-list">
							${this.renderBookmarkListItems()}
						</div>
					</div>

				<div class="ghcm-menu-group">
					<div class="ghcm-menu-group-title">Âü∫Á°ÄÊìç‰Ωú</div>
					<div class="ghcm-menu-item" data-action="collapseAll">
						<div class="ghcm-menu-item-icon">üìÅ</div>
						<div class="ghcm-menu-item-text">ÊäòÂè†ÊâÄÊúâ</div>
						<div class="ghcm-menu-item-shortcut">${CONFIG.hotkeys.collapseAll}</div>
					</div>
					<div class="ghcm-menu-item" data-action="expandAll">
						<div class="ghcm-menu-item-icon">üìÇ</div>
						<div class="ghcm-menu-item-text">Â±ïÂºÄÊâÄÊúâ</div>
						<div class="ghcm-menu-item-shortcut">${CONFIG.hotkeys.expandAll}</div>
					</div>
					<div class="ghcm-menu-item" data-action="toggleAll">
						<div class="ghcm-menu-item-icon">üîÑ</div>
						<div class="ghcm-menu-item-text">Êô∫ËÉΩÂàáÊç¢</div>
						<div class="ghcm-menu-item-shortcut">${CONFIG.hotkeys.toggleAll}</div>
					</div>
				</div>

				<div class="ghcm-menu-group">
					<div class="ghcm-menu-group-title">Â∑•ÂÖ∑ÂäüËÉΩ</div>
					<div class="ghcm-menu-item" data-action="showToc">
						<div class="ghcm-menu-item-icon">üìë</div>
						<div class="ghcm-menu-item-text">ÁõÆÂΩïÂØºËà™</div>
						<div class="ghcm-menu-item-shortcut">${CONFIG.hotkeys.showToc}</div>
					</div>
					<div class="ghcm-menu-item" data-action="showSearch">
						<div class="ghcm-menu-item-icon">üîç</div>
						<div class="ghcm-menu-item-text">ÊêúÁ¥¢Ê†áÈ¢ò</div>
						<div class="ghcm-menu-item-shortcut">${CONFIG.hotkeys.search}</div>
					</div>
				</div>

				<div class="ghcm-menu-group">
					<div class="ghcm-menu-group-title">ÊåâÁ∫ßÂà´Êìç‰Ωú</div>
					<div class="ghcm-menu-item" data-action="collapseLevel-2">
						<div class="ghcm-menu-item-icon">‚ûñ</div>
						<div class="ghcm-menu-item-text">‰ªÖÊäòÂè† H2</div>
					</div>
					<div class="ghcm-menu-item" data-action="expandLevel-2">
						<div class="ghcm-menu-item-icon">‚ûï</div>
						<div class="ghcm-menu-item-text">‰ªÖÂ±ïÂºÄ H2</div>
					</div>
					<div class="ghcm-menu-item" data-action="collapseLevel-3">
						<div class="ghcm-menu-item-icon">‚ûñ</div>
						<div class="ghcm-menu-item-text">‰ªÖÊäòÂè† H3</div>
					</div>
					<div class="ghcm-menu-item" data-action="expandLevel-3">
						<div class="ghcm-menu-item-icon">‚ûï</div>
						<div class="ghcm-menu-item-text">‰ªÖÂ±ïÂºÄ H3</div>
					</div>
				</div>

					<div class="ghcm-menu-group">
						<div class="ghcm-menu-group-title">ËÆæÁΩÆÈÄâÈ°π</div>
						<div class="ghcm-menu-item" data-action="togglePerformance">
							<div class="ghcm-menu-item-icon">‚ö°</div>
							<div class="ghcm-menu-item-text">ÊÄßËÉΩÊ®°Âºè</div>
							<div class="ghcm-menu-toggle ${CONFIG.animation.maxAnimatedElements === 0 ? 'active' : ''}" data-toggle="performance"></div>
						</div>
						<div class="ghcm-menu-item" data-action="toggleMemory">
							<div class="ghcm-menu-item-icon">üíæ</div>
							<div class="ghcm-menu-item-text">Áä∂ÊÄÅËÆ∞ÂøÜ</div>
							<div class="ghcm-menu-toggle ${CONFIG.memory.enabled ? 'active' : ''}" data-toggle="memory"></div>
						</div>
						<div class="ghcm-menu-item" data-action="toggleHotkeys">
							<div class="ghcm-menu-item-icon">‚å®Ô∏è</div>
							<div class="ghcm-menu-item-text">Âø´Êç∑ÈîÆ</div>
							<div class="ghcm-menu-toggle ${CONFIG.hotkeys.enabled ? 'active' : ''}" data-toggle="hotkeys"></div>
						</div>
						<div class="ghcm-menu-item" data-action="toggleVimNav">
							<div class="ghcm-menu-item-icon">üß≠</div>
							<div class="ghcm-menu-item-text">Vim ÂØºËà™ÁÉ≠ÈîÆ</div>
							<div class="ghcm-menu-toggle ${CONFIG.hotkeys.navEnabled ? 'active' : ''}" data-toggle="vimNav"></div>
						</div>
						<div class="ghcm-menu-item" data-action="toggleDebug">
							<div class="ghcm-menu-item-icon">üêõ</div>
							<div class="ghcm-menu-item-text">Ë∞ÉËØïÊ®°Âºè</div>
							<div class="ghcm-menu-toggle ${CONFIG.debug ? 'active' : ''}" data-toggle="debug"></div>
						</div>
				</div>

					<div class="ghcm-menu-group">
						<div class="ghcm-menu-group-title">Ê†∑ÂºèËÆæÁΩÆ</div>
						<div class="ghcm-menu-item" data-action="toggleShowLevelNumber">
							<div class="ghcm-menu-item-icon">üîΩ</div>
							<div class="ghcm-menu-item-text">‰ªÖÊòæÁ§∫ÁÆ≠Â§¥</div>
							<div class="ghcm-menu-toggle ${CONFIG.ui.showLevelNumber ? '' : 'active'}" data-toggle="showLevel"></div>
						</div>
						<div class="ghcm-menu-item" data-action="customColors">
							<div class="ghcm-menu-item-icon">üñåÔ∏è</div>
							<div class="ghcm-menu-item-text">Ëá™ÂÆö‰πâÈÖçËâ≤</div>
						</div>
						<div class="ghcm-menu-item" data-action="adjustArrowSize">
							<div class="ghcm-menu-item-icon">üî†</div>
							<div class="ghcm-menu-item-text">ÁÆ≠Â§¥Â§ßÂ∞è</div>
							<div class="ghcm-menu-item-note" data-arrow-size-value>${CONFIG.ui.arrowSize}</div>
						</div>
						<div class="ghcm-menu-item" data-action="setColors-default">
							<div class="ghcm-menu-item-icon">üé®</div>
							<div class="ghcm-menu-item-text">ÈªòËÆ§ÈÖçËâ≤</div>
						</div>
					<div class="ghcm-menu-item" data-action="setColors-pastel">
						<div class="ghcm-menu-item-icon">üé®</div>
						<div class="ghcm-menu-item-text">ÊüîÂíå Pastel</div>
					</div>
					<div class="ghcm-menu-item" data-action="setColors-vibrant">
						<div class="ghcm-menu-item-icon">üé®</div>
						<div class="ghcm-menu-item-text">È≤úËâ≥ Vibrant</div>
					</div>
					<div class="ghcm-menu-item" data-action="setColors-mono">
						<div class="ghcm-menu-item-icon">üé®</div>
						<div class="ghcm-menu-item-text">ÂçïËâ≤ Mono</div>
					</div>
				</div>

				<div class="ghcm-menu-group">
					<div class="ghcm-menu-group-title">ÈáçÁΩÆÂäüËÉΩ</div>
					<div class="ghcm-menu-item" data-action="resetStates">
						<div class="ghcm-menu-item-icon">üîÑ</div>
						<div class="ghcm-menu-item-text">ÈáçÁΩÆÁä∂ÊÄÅ</div>
					</div>
					<div class="ghcm-menu-item" data-action="clearMemory">
						<div class="ghcm-menu-item-icon">üóëÔ∏è</div>
						<div class="ghcm-menu-item-text">Ê∏ÖÈô§ËÆ∞ÂøÜ</div>
					</div>
				</div>

				<div class="ghcm-menu-group">
					<div class="ghcm-menu-group-title">Â∏ÆÂä©‰ø°ÊÅØ</div>
					<div class="ghcm-menu-item" data-action="showHelp">
						<div class="ghcm-menu-item-icon">‚ÑπÔ∏è</div>
						<div class="ghcm-menu-item-text">‰ΩøÁî®ËØ¥Êòé</div>
					</div>
				</div>
			`;
		}

		setupMenuEvents(container) {
			// ÁÇπÂáªËèúÂçïÈ°π‰∫ã‰ª∂
			container.addEventListener('click', (e) => {
				const removeBtn = e.target.closest('[data-remove-bookmark]');
				if (removeBtn) {
					const index = parseInt(removeBtn.getAttribute('data-remove-bookmark'), 10);
					this.app.bookmarkManager.removeBookmarkByIndex(index);
					this.updateBookmarkList();
					e.stopPropagation();
					return;
				}

				const item = e.target.closest('.ghcm-menu-item');
				if (!item) return;

				const action = item.getAttribute('data-action');
				const toggle = e.target.closest('.ghcm-menu-toggle');

				if (toggle) {
					this.handleToggle(toggle);
					return;
				}

				if (action) {
					const shouldClose = this.handleAction(action);
					if (shouldClose !== false) {
						this.hide();
					}
				}
			});

			// ÈòªÊ≠¢ËèúÂçïÂÆπÂô®ÂÜÖÁöÑÁÇπÂáª‰∫ã‰ª∂ÂÜíÊ≥°
			container.addEventListener('click', (e) => {
				e.stopPropagation();
			});
		}

		handleAction(action) {
			let shouldClose = true;
			switch (action) {
				case 'collapseAll':
					this.app.collapseManager.collapseAll();
					break;
				case 'expandAll':
					this.app.collapseManager.expandAll();
					break;
				case 'toggleAll':
					this.app.collapseManager.toggleAll();
					break;
				case 'showToc':
					this.app.tocGenerator.toggle();
					break;
				case 'showSearch':
					this.app.searchManager.toggle();
					break;
				case 'togglePerformance':
					this.app.togglePerformanceMode();
					this.refreshMenu();
					break;
				case 'toggleMemory':
					this.app.toggleMemory();
					this.refreshMenu();
					break;
				case 'toggleHotkeys':
					this.app.toggleHotkeys();
					this.refreshMenu();
					break;
				case 'toggleVimNav':
					this.app.toggleVimNav();
					this.refreshMenu();
					break;
				case 'toggleDebug':
					this.app.toggleDebug();
					this.refreshMenu();
					break;
				case 'bookmark-add':
					this.app.bookmarkManager.addBookmarkFromViewport();
					this.refreshMenu();
					shouldClose = false;
					break;
				case 'bookmark-clear':
					this.app.bookmarkManager.clearPageBookmarks();
					this.refreshMenu();
					shouldClose = false;
					break;
				case 'customColors':
					this.app.promptCustomColors();
					this.refreshMenu();
					shouldClose = false;
					break;
				case 'adjustArrowSize':
					this.app.promptArrowSize();
					this.refreshMenu();
					shouldClose = false;
					break;
				case 'resetStates':
					if (confirm('Á°ÆÂÆöË¶ÅÈáçÁΩÆÂΩìÂâçÈ°µÈù¢ÁöÑÊâÄÊúâÊäòÂè†Áä∂ÊÄÅÂêóÔºü')) {
						this.app.resetAllStates();
						this.refreshMenu();
					}
					break;
				case 'clearMemory':
					if (confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÈô§ÊâÄÊúâÈ°µÈù¢ÁöÑËÆ∞ÂøÜÊï∞ÊçÆÂêóÔºü')) {
						this.app.clearAllMemory();
						this.refreshMenu();
					}
					break;
				case 'showHelp':
					this.app.showHotkeyHelp();
					break;
				default:
					if (action.startsWith('bookmark-open-')) {
						const idx = parseInt(action.split('-')[2], 10);
						if (!Number.isFinite(idx)) {
							shouldClose = false;
							break;
						}
						this.app.bookmarkManager.openBookmarkByIndex(idx);
						break;
					}
					if (action.startsWith('collapseLevel-')) {
						const lvl = parseInt(action.split('-')[1], 10);
						this.app.collapseManager.collapseLevel(lvl);
						break;
					}
					if (action.startsWith('expandLevel-')) {
						const lvl = parseInt(action.split('-')[1], 10);
						this.app.collapseManager.expandLevel(lvl);
						break;
					}
					if (action === 'toggleShowLevelNumber') {
						this.app.toggleShowLevelNumber();
						this.refreshMenu();
						break;
					}
					if (action.startsWith('setColors-')) {
						const scheme = action.split('-')[1];
						this.app.setColorScheme(scheme);
						this.refreshMenu();
						break;
					}
			}
			return shouldClose;
		}

		handleToggle(toggle) {
			const toggleType = toggle.getAttribute('data-toggle');
			const isActive = toggle.classList.contains('active');

			toggle.classList.toggle('active', !isActive);

			switch (toggleType) {
				case 'performance':
					this.app.togglePerformanceMode();
					break;
				case 'memory':
					this.app.toggleMemory();
					break;
				case 'hotkeys':
					this.app.toggleHotkeys();
					break;
				case 'vimNav':
					this.app.toggleVimNav();
					break;
				case 'debug':
					this.app.toggleDebug();
					break;
				case 'showLevel':
					this.app.toggleShowLevelNumber();
					break;
			}
		}

		getStatistics() {
			const headers = this.app.collapseManager.getAllHeaders();
			const collapsed = headers.filter(h => h.classList.contains(CONFIG.classes.collapsed));
			const visible = headers.filter(h =>
				!h.classList.contains(CONFIG.classes.collapsed) &&
				!h.classList.contains(CONFIG.classes.noContent)
			);

			return {
				total: headers.length,
				collapsed: collapsed.length,
				visible: visible.length
			};
		}

		refreshMenu() {
			if (!this.menuContainer || !this.isVisible) return;
			const stats = this.getStatistics();
			this.updateMenuStats(stats);
			this.syncToggleState('performance', CONFIG.animation.maxAnimatedElements === 0);
			this.syncToggleState('memory', CONFIG.memory.enabled);
			this.syncToggleState('hotkeys', CONFIG.hotkeys.enabled);
			this.syncToggleState('vimNav', CONFIG.hotkeys.navEnabled);
			this.syncToggleState('debug', CONFIG.debug);
			// showLevel toggle active ‰ª£Ë°®‰ªÖÊòæÁ§∫ÁÆ≠Â§¥
			this.syncToggleState('showLevel', !CONFIG.ui.showLevelNumber);
			this.updateBookmarkList();
			this.updateArrowSizeValue();
		}

		updateMenuStats(stats) {
			if (!this.menuContainer) return;
			const mapping = {
				total: stats.total,
				collapsed: stats.collapsed,
				visible: stats.visible
			};
			Object.entries(mapping).forEach(([key, value]) => {
				const el = this.menuContainer.querySelector(`.ghcm-menu-stats-value[data-stat="${key}"]`);
				if (el) el.textContent = String(value);
			});
		}

			syncToggleState(toggleType, isActive) {
			if (!this.menuContainer) return;
			const toggle = this.menuContainer.querySelector(`.ghcm-menu-toggle[data-toggle="${toggleType}"]`);
			if (toggle) {
				toggle.classList.toggle('active', !!isActive);
			}
		}

		updateBookmarkList() {
			if (!this.menuContainer) return;
			const list = this.menuContainer.querySelector('.ghcm-bookmark-list');
			if (list) {
				list.innerHTML = this.renderBookmarkListItems();
			}
		}

		updateArrowSizeValue() {
			if (!this.menuContainer) return;
			const value = this.menuContainer.querySelector('[data-arrow-size-value]');
			if (value) value.textContent = CONFIG.ui.arrowSize;
		}

		renderBookmarkListItems() {
			const bookmarks = this.app.bookmarkManager?.getBookmarksForCurrentPage?.() || [];
			if (!bookmarks.length) {
				return `<div class="ghcm-bookmark-empty">ÊöÇÊó†‰π¶Á≠æ</div>`;
			}
			return bookmarks.map((bookmark, index) => {
				const levelLabel = typeof bookmark.level === 'number' ? `H${bookmark.level}` : 'H?';
				return `
					<div class="ghcm-menu-item ghcm-bookmark-item" data-action="bookmark-open-${index}">
						<div class="ghcm-bookmark-info">
							<span class="ghcm-bookmark-level">${levelLabel}</span>
							<span class="ghcm-bookmark-text">${this.escapeHtml(bookmark.text || 'Êú™ÂëΩÂêçÊ†áÈ¢ò')}</span>
						</div>
						<button class="ghcm-bookmark-remove" type="button" data-remove-bookmark="${index}" aria-label="ÁßªÈô§‰π¶Á≠æ">‚úï</button>
					</div>
				`;
			}).join('');
		}

		escapeHtml(text) {
			return String(text ?? '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
		}

		show() {
			if (this.isVisible) return;

			if (this.menuContainer) {
				this.menuContainer.remove();
			}

			// ÊâìÂºÄËèúÂçïÂâçÂÖ≥Èó≠ÂÖ∂‰ªñÊµÆÂ±Ç
			try { this.app.tocGenerator.hideToc(); } catch {}
			try { this.app.searchManager.hideSearch(); } catch {}

			this.menuContainer = this.createMenuContainer();
			document.body.appendChild(this.menuContainer);

			// Âä®ÁîªÊòæÁ§∫
			requestAnimationFrame(() => {
				this.menuContainer.classList.add('show');
			});

			this.menuButton.classList.add('menu-open');
			this.menuButton.setAttribute('aria-expanded', 'true');
			this.isVisible = true;

			// ÁÇπÂáªÂ§ñÈÉ®ÂÖ≥Èó≠
			setTimeout(() => {
				document.addEventListener('click', this.hideOnClickOutside);
			}, 100);

			// ESC ÂÖ≥Èó≠
			this._keyHandler = (e) => {
				if (e.key === 'Escape') this.hide();
			};
			document.addEventListener('keydown', this._keyHandler);

			// ÂàùÂßãÁÑ¶ÁÇπ
			try { this.menuContainer.setAttribute('tabindex','-1'); this.menuContainer.focus(); } catch {}
		}

		hide() {
			if (!this.isVisible || !this.menuContainer) return;

			this.menuContainer.classList.remove('show');
			this.menuButton.classList.remove('menu-open');
			this.menuButton.setAttribute('aria-expanded', 'false');

			setTimeout(() => {
				if (this.menuContainer) {
					this.menuContainer.remove();
					this.menuContainer = null;
				}
			}, 300);

			this.isVisible = false;
			document.removeEventListener('click', this.hideOnClickOutside);
			if (this._keyHandler) {
				document.removeEventListener('keydown', this._keyHandler);
				this._keyHandler = null;
			}
		}

		toggle() {
			if (this.isVisible) {
				this.hide();
			} else {
				this.show();
			}
		}

		hideOnClickOutside = (e) => {
			if (!this.menuContainer?.contains(e.target) &&
				!this.menuButton?.contains(e.target)) {
				this.hide();
			}
		}
	}

	class HelpModal {
		constructor(app) {
			this.app = app;
			this.overlay = null;
			this.modal = null;
			this.contentContainer = null;
			this.content = null;
			this.closeButton = null;
			this.previousActive = null;
			this.handleOverlayClick = this.handleOverlayClick.bind(this);
			this.handleKeydown = this.handleKeydown.bind(this);
		}

		ensureElements() {
			if (this.overlay) return;

			this.overlay = document.createElement('div');
			this.overlay.className = 'ghcm-help-overlay';

			this.modal = document.createElement('div');
			this.modal.className = 'ghcm-help-modal';
			this.modal.setAttribute('role', 'dialog');
			this.modal.setAttribute('aria-modal', 'true');
			this.modal.setAttribute('aria-label', 'GitHub Collapse Markdown ‰ΩøÁî®ËØ¥Êòé');
			this.modal.setAttribute('tabindex', '-1');

			const header = document.createElement('div');
			header.className = 'ghcm-help-header';

			const title = document.createElement('div');
			title.className = 'ghcm-help-title';

			const titleText = document.createElement('span');
			titleText.className = 'ghcm-help-title-text';
			titleText.textContent = 'GitHub Collapse Markdown';

			const titleSub = document.createElement('span');
			titleSub.className = 'ghcm-help-title-sub';
			titleSub.textContent = '‰ΩøÁî®ËØ¥Êòé';

			title.append(titleText, titleSub);

			this.closeButton = document.createElement('button');
			this.closeButton.type = 'button';
			this.closeButton.className = 'ghcm-help-close';
			this.closeButton.setAttribute('aria-label', 'ÂÖ≥Èó≠‰ΩøÁî®ËØ¥ÊòéÂºπÁ™ó');
			this.closeButton.textContent = '‚úï';
			this.closeButton.addEventListener('click', () => this.hide());

			header.append(title, this.closeButton);

			this.contentContainer = document.createElement('div');
			this.contentContainer.className = 'ghcm-help-content';

			this.content = document.createElement('article');
			this.content.className = 'markdown-body';
			this.contentContainer.appendChild(this.content);

			this.modal.append(header, this.contentContainer);
			this.overlay.appendChild(this.modal);
		}

		show() {
			this.ensureElements();
			this.previousActive = document.activeElement instanceof HTMLElement ? document.activeElement : null;

			this.updateContent();

			try { this.app.menuManager?.hide(); } catch {}
			try { this.app.tocGenerator?.hideToc?.(); } catch {}
			try { this.app.searchManager?.hideSearch?.(); } catch {}

			if (!this.overlay.isConnected) {
				document.body.appendChild(this.overlay);
			}

			requestAnimationFrame(() => {
				this.overlay.classList.add('show');
			});

			document.addEventListener('keydown', this.handleKeydown, true);
			this.overlay.addEventListener('click', this.handleOverlayClick);

			try { this.modal.focus(); } catch {}
		}

		hide() {
			if (!this.overlay) return;
			this.overlay.classList.remove('show');
			document.removeEventListener('keydown', this.handleKeydown, true);
			this.overlay.removeEventListener('click', this.handleOverlayClick);

			setTimeout(() => {
				if (this.overlay?.parentNode) {
					this.overlay.parentNode.removeChild(this.overlay);
				}
			}, 220);

			if (this.previousActive) {
				try { this.previousActive.focus(); } catch {}
			}
		}

		handleOverlayClick(event) {
			if (event.target === this.overlay) {
				this.hide();
			}
		}

		handleKeydown(event) {
			if (event.key === 'Escape') {
				event.stopPropagation();
				event.preventDefault();
				this.hide();
			}
		}

		updateContent() {
			if (!this.content) return;
			this.content.innerHTML = this.generateContentHTML();
			this.contentContainer.scrollTop = 0;
		}

		generateContentHTML() {
			const hotkeys = CONFIG.hotkeys;
			const navHint = hotkeys.navEnabled ? 'ÔºàVim ÂØºËà™Â∑≤ÂêØÁî®Ôºâ' : 'ÔºàÈªòËÆ§ÂÖ≥Èó≠ÔºåÂèØÂú®ËÆæÁΩÆ‰∏≠ÂºÄÂêØÔºâ';
			return `
<h1>üöÄ GitHub Collapse Markdown ‰ΩøÁî®ÊåáÂçó</h1>
<p>ËÑöÊú¨‰∏∫ GitHub ‰∏äÁöÑ Markdown„ÄÅIssue„ÄÅPR ‰∏é Gist È°µÈù¢Êèê‰æõÊ†áÈ¢òÊäòÂè†„ÄÅÁõÆÂΩïÂØºËà™„ÄÅÊêúÁ¥¢„ÄÅ‰π¶Á≠æ‰∏éÁä∂ÊÄÅËÆ∞ÂøÜÁ≠âÂ¢ûÂº∫ÂäüËÉΩ„ÄÇÊú¨ÊåáÂçóÊ∂µÁõñÂø´ÈÄüÂÖ•Èó®„ÄÅÂø´Êç∑ÈîÆ„ÄÅÁïåÈù¢Êìç‰Ωú„ÄÅËÆæÁΩÆÈ°π‰∏éËøõÈò∂ÊäÄÂ∑ß„ÄÇ</p>

<section class="ghcm-help-section">
	<h2>‚ö° Âø´ÈÄüÂºÄÂßã</h2>
	<ol>
		<li>ÊâìÂºÄ‰ªªÊÑèÊîØÊåÅÁöÑ GitHub È°µÈù¢ÔºåËÑöÊú¨‰ºöÂú®Âè≥‰∏ãËßíÁîüÊàêÊµÆÂä®ËèúÂçïÊåâÈíÆ„ÄÇ</li>
		<li>ÁÇπÂáª‰ªªÊÑèÊ†áÈ¢òÂç≥ÂèØÊäòÂè†/Â±ïÂºÄÂØπÂ∫îÂÜÖÂÆπÔºåÂµåÂ•óÊ†áÈ¢ò‰ºöÊô∫ËÉΩ‰øùÊåÅÂ±ÇÁ∫ßÁä∂ÊÄÅ„ÄÇ</li>
		<li>‰ΩøÁî®Âè≥‰∏ãËßíËèúÂçïÊàñÂø´Êç∑ÈîÆ ${this.wrapHotkey(hotkeys.menu)} ÂëºÂá∫ËÆæÁΩÆÈù¢ÊùøÔºåÊé¢Á¥¢ÁõÆÂΩï„ÄÅÊêúÁ¥¢ÂíåËá™ÂÆö‰πâÈÄâÈ°π„ÄÇ</li>
		<li>ÊäòÂè†Áä∂ÊÄÅ‰∏é‰π¶Á≠æ‰ºöÈíàÂØπÂΩìÂâçÈ°µÈù¢Ëá™Âä®‰øùÂ≠òÔºåÂà∑Êñ∞Âêé‰ªç‰øùÊåÅ„ÄÇ</li>
	</ol>
</section>

<section class="ghcm-help-section">
	<h2>‚å®Ô∏è Âø´Êç∑ÈîÆÈÄüÊü•</h2>
	<div class="ghcm-help-grid">
		<div class="ghcm-help-card">
			<h3>ÊäòÂè†‰∏éËßÜÂõæ</h3>
			${this.renderShortcut('ÊäòÂè†ÂÖ®ÈÉ®', hotkeys.collapseAll)}
			${this.renderShortcut('Â±ïÂºÄÂÖ®ÈÉ®', hotkeys.expandAll)}
			${this.renderShortcut('Êô∫ËÉΩÂàáÊç¢', hotkeys.toggleAll)}
			${this.renderShortcut('ÊòæÁ§∫ËèúÂçï', hotkeys.menu)}
		</div>
		<div class="ghcm-help-card">
			<h3>ÂØºËà™Â∑•ÂÖ∑</h3>
			${this.renderShortcut('ÊâìÂºÄÁõÆÂΩï', hotkeys.showToc)}
			${this.renderShortcut('ÊêúÁ¥¢Ê†áÈ¢ò', hotkeys.search)}
			${this.renderShortcut('Êî∂ËóèÂΩìÂâçÊ†áÈ¢ò', hotkeys.bookmark)}
		</div>
		<div class="ghcm-help-card">
			<h3>È´òÁ∫ßÂØºËà™ ${this.escapeHtml(navHint)}</h3>
			${this.renderShortcut('‰∏ã‰∏ÄÊ†áÈ¢ò', hotkeys.nextHeading)}
			${this.renderShortcut('‰∏ä‰∏ÄÊ†áÈ¢ò', hotkeys.prevHeading)}
		</div>
	</div>
	<p class="ghcm-help-footnote">Âø´Êç∑ÈîÆÂèØÂú®ËÆæÁΩÆËèúÂçï‰∏≠Êï¥‰ΩìÂºÄÂÖ≥ÔºõÊî∂Ëóè„ÄÅÂØºËà™ÈîÆ‰ΩçÂùáÊîØÊåÅËá™ÂÆö‰πâÔºàTampermonkey ËèúÂçïÔºâ„ÄÇ</p>
</section>

<section class="ghcm-help-section">
	<h2>üñ±Ô∏è Èº†Ê†áÊâãÂäø</h2>
	<ul class="ghcm-help-list">
		<li><strong>ÂçïÂáªÊ†áÈ¢ò</strong><span>ÊäòÂè†ÊàñÂ±ïÂºÄÂØπÂ∫îÂÜÖÂÆπÂùó„ÄÇ</span></li>
		<li><strong>Shift + ÂçïÂáª</strong><span>ÂêåÊ≠•ÊäòÂè†/Â±ïÂºÄÂΩìÂâçÂ±ÇÁ∫ßÊâÄÊúâÊ†áÈ¢ò„ÄÇ</span></li>
		<li><strong>ÊÇ¨ÂÅúÊ†áÈ¢ò</strong><span>Êü•ÁúãÂΩìÂâçÂ±ÇÁ∫ßÈ´ò‰∫ÆÔºåÈÖçÂêàÁõÆÂΩïÂÆö‰ΩçÊõ¥Áõ¥ËßÇ„ÄÇ</span></li>
		<li><strong>Âè≥‰∏ãËßíËèúÂçïÊåâÈíÆ</strong><span>ÊâìÂºÄÁé∞‰ª£Âåñ GUIÔºåÈõÜ‰∏≠ÁÆ°ÁêÜÊâÄÊúâÂäüËÉΩ„ÄÇ</span></li>
	</ul>
</section>

<section class="ghcm-help-section">
	<h2>üéõÔ∏è ‰∏ªË¶ÅÁïåÈù¢</h2>
	<div class="ghcm-help-grid">
		<div class="ghcm-help-card">
			<h3>ÁõÆÂΩïÂØºËà™</h3>
			<p>‰ª•Ê†ëÂΩ¢ÁªìÊûÑÂ±ïÁ§∫È°µÈù¢ÊâÄÊúâÊ†áÈ¢òÔºåÊîØÊåÅËá™Âä®ÊäòÂè†ÂêåÊ≠•„ÄÅÂø´ÈÄüË∑≥ËΩ¨‰∏éÂΩìÂâçÊ†áÈ¢òÈ´ò‰∫Æ„ÄÇ</p>
		</div>
		<div class="ghcm-help-card">
			<h3>Ê†áÈ¢òÊêúÁ¥¢</h3>
			<p>Âç≥Êó∂Á¥¢ÂºïÂΩìÂâçÈ°µÈù¢Ê†áÈ¢òÔºåÊîØÊåÅÊ®°Á≥äÂåπÈÖç„ÄÅÈîÆÁõò‰∏ä‰∏ãÈîÆÂàáÊç¢ÁªìÊûú‰ª•Âèä Tab/Shift+Tab Âú®ËæìÂÖ•Ê°Ü‰∏éÁªìÊûúÈó¥ÁßªÂä®„ÄÇ</p>
		</div>
		<div class="ghcm-help-card">
			<h3>‰π¶Á≠æÈù¢Êùø</h3>
			<p>‰∏∫Â∏∏Áî®ÊÆµËêΩÊ∑ªÂä†Êî∂ËóèÔºåÊîØÊåÅ‰ªéËßÜÁ™óÊçïËé∑„ÄÅÂàóË°®Ë∑≥ËΩ¨‰∏é‰∏ÄÈîÆÊ∏ÖÈô§ÔºåË∑®‰ºöËØùÊåÅ‰πÖ‰øùÂ≠ò„ÄÇ</p>
		</div>
	</div>
</section>

<section class="ghcm-help-section">
	<h2>‚öôÔ∏è ËÆæÁΩÆÈÄâÈ°π</h2>
	<ul class="ghcm-help-list">
		<li><strong>ÊÄßËÉΩÊ®°Âºè</strong><span>Âú®ÈïøÁØáÊñáÊ°£‰∏≠Á¶ÅÁî®Âä®ÁîªÔºåÊèêÂçáÊªöÂä®‰∏éÂàáÊç¢ÂìçÂ∫î„ÄÇ</span></li>
		<li><strong>Áä∂ÊÄÅËÆ∞ÂøÜ</strong><span>ÊåâÈ°µÈù¢‰øùÂ≠òÊäòÂè†Áä∂ÊÄÅ‰∏éÂ±ïÂºÄÂÅèÂ•ΩÔºåÂèØÈöèÊó∂Ê∏ÖÁ©∫„ÄÇ</span></li>
		<li><strong>Âø´Êç∑ÈîÆÊÄªÂºÄÂÖ≥</strong><span>‰∏é Vim ÂØºËà™Áã¨Á´ãÊéßÂà∂ÔºåÊª°Ë∂≥‰∏çÂêåÁºñËæë‰π†ÊÉØ„ÄÇ</span></li>
		<li><strong>ÁÆ≠Â§¥Â§ñËßÇ</strong><span>ÂèØÂàáÊç¢ÊòæÁ§∫Á∫ßÂà´Êï∞Â≠ó„ÄÅË∞ÉÊï¥ÁÆ≠Â§¥Â∞∫ÂØ∏Âπ∂Ëá™ÂÆö‰πâÈÖçËâ≤„ÄÇ</span></li>
	</ul>
</section>

<section class="ghcm-help-section">
	<h2>üí° ÂÆûÁî®ÊäÄÂ∑ß</h2>
	<ul class="ghcm-help-list">
		<li><strong>Êô∫ËÉΩÂµåÂ•ó</strong><span>Â±ïÂºÄÁà∂Á∫ßÊ†áÈ¢ò‰∏ç‰ºöÂº∫Âà∂Â±ïÂºÄÂ≠êÁ∫ßÔºå‰øùÊåÅÈòÖËØª‰∏ä‰∏ãÊñá„ÄÇ</span></li>
		<li><strong>ÂìàÂ∏åÂÆö‰Ωç</strong><span>ËÆøÈóÆÂê´ÈîöÁÇπÈìæÊé•Êó∂Ëá™Âä®Â±ïÂºÄÁõ∏ÂÖ≥Ê†áÈ¢òÂπ∂ÊªöÂä®Âà∞ËßÜÂõæ„ÄÇ</span></li>
		<li><strong>Ë∑®È°µÈù¢ËÆ∞ÂøÜ</strong><span>Issue / PR / Wiki / ÊñáÊ°£È°µÈù¢Âùá‰ª• URL ‰∏∫ÈîÆ‰øùÂ≠òÁä∂ÊÄÅ„ÄÇ</span></li>
		<li><strong>Ë∞ÉËØïÊ®°Âºè</strong><span>ÂêØÁî®ÂêéÂú®ÊéßÂà∂Âè∞ËæìÂá∫ÂÜÖÈÉ®Áä∂ÊÄÅÔºå‰æø‰∫éÊéíÊü•Ëá™ÂÆö‰πâÂÜ≤Á™Å„ÄÇ</span></li>
	</ul>
</section>

<p class="ghcm-help-footnote">Â¶ÇÈÅáÊäòÂè†ÂºÇÂ∏∏ÔºåÂèØÂú®ËèúÂçï‰∏≠Ê∏ÖÁ©∫ËÆ∞ÂøÜÊï∞ÊçÆÊàñÂà∑Êñ∞È°µÈù¢ÈáçÊñ∞Âä†ËΩΩËÑöÊú¨ÔºõÊ¨¢ËøéÂú® GitHub Issues Êèê‰∫§ÂèçÈ¶à‰∏éÂª∫ËÆÆ„ÄÇ</p>
`.trim();
		}

		renderShortcut(label, hotkey) {
			return `
		<div class="ghcm-help-shortcut">
			<span>${this.escapeHtml(label)}</span>
			${this.wrapHotkey(hotkey)}
		</div>
		`.trim();
		}

		wrapHotkey(hotkey) {
			return `<span class="ghcm-help-kbd"><span>${this.escapeHtml(hotkey || 'Êú™ËÆæÁΩÆ')}</span></span>`;
		}

		escapeHtml(text) {
			return String(text ?? '').replace(/[&<>"']/g, char => ({
				'&': '&amp;',
				'<': '&lt;',
				'>': '&gt;',
				'"': '&quot;',
				"'": '&#39;'
			}[char] || char));
		}
	}

	// Áä∂ÊÄÅÁÆ°ÁêÜ
	class StateManager {
		constructor() {
			this.headerStates = new Map();
			this.observers = [];
			this.pageUrl = this.getPageKey();
			this._saveTimer = null;
			this._pendingSave = false;
			this._saveDelay = 200;
			try {
				window.addEventListener('beforeunload', () => this.flushPendingSave());
			} catch {}
		}

		getPageKey() {
			try {
				return `${window.location.origin}${window.location.pathname}`;
			} catch (e) {
				return window.location.href;
			}
		}

		updatePageKey() {
			const newKey = this.getPageKey();
			if (newKey !== this.pageUrl) {
				this.headerStates.clear();
				this.pageUrl = newKey;
			}
		}

		setHeaderState(headerKey, state) {
			this.headerStates.set(headerKey, state);
			this.scheduleSave();
		}

		getHeaderState(headerKey) {
			return this.headerStates.get(headerKey);
		}

		generateHeaderKey(element) {
			// ‰ºòÂÖà‰ΩøÁî®Á®≥ÂÆöÁöÑ DOM id/ÈîöÁÇπÔºåÈÅøÂÖçÊñáÊú¨Êàñ‰ΩçÁΩÆÂèòÂåñÂØºËá¥Áä∂ÊÄÅÈîôÈÖç
			try {
				const normalize = value => (typeof value === 'string' ? value.trim() : '');
				const isSynthetic = id => /^ghcm-(?:bookmark|h)-/i.test(id || '');
				const stableId = (() => {
					const directId = normalize(element.getAttribute?.('id') || element.id);
					if (directId && !isSynthetic(directId)) return directId;

					const anchor = element.querySelector?.('.anchor');
					if (anchor) {
						const anchorId = normalize(anchor.getAttribute('id'));
						if (anchorId && !isSynthetic(anchorId)) return anchorId;
						const hrefId = normalize(anchor.getAttribute('href')?.replace(/^#/, ''));
						if (hrefId && !isSynthetic(hrefId)) return hrefId;
					}

					const anyWithId = element.querySelector?.('[id]');
					const childId = normalize(anyWithId?.getAttribute('id'));
					if (childId && !isSynthetic(childId)) return childId;
					return null;
				})();

				if (stableId) return `id:${stableId}`;
			} catch {}

			// ÂõûÈÄÄÂà∞Âü∫‰∫é level+ÊñáÊú¨+‰ΩçÁΩÆ ÁöÑÈîÆ
			const level = this.getHeaderLevel(element);
			const text = element.textContent?.trim() || "";
			const position = Array.from(element.parentElement?.children || []).indexOf(element);
			return `${level}-${text}-${position}`;
		}

		getHeaderLevel(element) {
			return DOMUtils.getHeadingLevel(element);
		}

		clear() {
			this.headerStates.clear();
			this.scheduleSave({ force: true });
		}

		// Áä∂ÊÄÅËÆ∞ÂøÜÂäüËÉΩ
		scheduleSave({ force = false } = {}) {
			if (!CONFIG.memory.enabled) {
				this.cancelScheduledSave();
				return;
			}

			this._pendingSave = true;
			if (force) {
				this.flushPendingSave();
				return;
			}

			if (this._saveTimer) return;
			this._saveTimer = setTimeout(() => {
				this.flushPendingSave();
			}, this._saveDelay);
		}

		cancelScheduledSave() {
			if (this._saveTimer) {
				clearTimeout(this._saveTimer);
				this._saveTimer = null;
			}
			this._pendingSave = false;
		}

		flushPendingSave() {
			if (!this._pendingSave) return;
			this._pendingSave = false;
			if (this._saveTimer) {
				clearTimeout(this._saveTimer);
				this._saveTimer = null;
			}
			if (!CONFIG.memory.enabled) return;

			try {
				const pageStates = GM_getValue(CONFIG.memory.key, {});
				const currentStates = {};

				this.headerStates.forEach((state, key) => {
					currentStates[key] = state.isCollapsed;
				});

				pageStates[this.pageUrl] = currentStates;
				GM_setValue(CONFIG.memory.key, pageStates);
			} catch (e) {
				Logger.warn("[GHCM] ‰øùÂ≠òÁä∂ÊÄÅÂ§±Ë¥•:", e);
			}
		}

		loadFromMemory() {
			if (!CONFIG.memory.enabled) return;

			try {
				const pageStates = GM_getValue(CONFIG.memory.key, {});
				const currentStates = pageStates[this.pageUrl];

				if (currentStates) {
					Object.entries(currentStates).forEach(([key, isCollapsed]) => {
						this.headerStates.set(key, { isCollapsed });
					});
					Logger.log(`[GHCM] Â∑≤Âä†ËΩΩ ${Object.keys(currentStates).length} ‰∏™Â∑≤‰øùÂ≠òÁöÑÁä∂ÊÄÅ`);
				}
			} catch (e) {
				Logger.warn("[GHCM] Âä†ËΩΩÁä∂ÊÄÅÂ§±Ë¥•:", e);
			}
		}

		clearMemory() {
			try {
				const pageStates = GM_getValue(CONFIG.memory.key, {});
				delete pageStates[this.pageUrl];
				GM_setValue(CONFIG.memory.key, pageStates);
				Logger.log("[GHCM] Â∑≤Ê∏ÖÈô§ÂΩìÂâçÈ°µÈù¢ÁöÑËÆ∞ÂøÜÁä∂ÊÄÅ");
			} catch (e) {
				Logger.warn("[GHCM] Ê∏ÖÈô§Áä∂ÊÄÅÂ§±Ë¥•:", e);
			}
		}
	}

	// Âø´Êç∑ÈîÆÁÆ°ÁêÜÂô®
	const EVENT_HANDLED_FLAG = '__ghcmHotkeyHandled__';

	class HotkeyManager {
		constructor(collapseManager) {
			this.collapseManager = collapseManager;
			this._boundHandler = null;
			this._isBound = false;
			this.app = null;
			this._listenerOptions = { capture: true, passive: false };
			const nativeWindow = (() => {
				try { return typeof unsafeWindow !== 'undefined' ? unsafeWindow : window; }
				catch { return window; }
			})();
			this._listenerTargets = Array.from(new Set([nativeWindow, document]));
			this.setupHotkeys();
		}

		setApp(app) {
			this.app = app;
		}

		setupHotkeys() {
			if (!CONFIG.hotkeys.enabled || this._isBound) return;

			if (!this._boundHandler) {
				this._boundHandler = this.handleKeyDown.bind(this);
			}
			this._listenerTargets.forEach(target => {
				try { target.addEventListener('keydown', this._boundHandler, this._listenerOptions); } catch {}
			});
			this._isBound = true;
			Logger.log("[GHCM] Âø´Êç∑ÈîÆÂ∑≤ÂêØÁî®:", Object.entries(CONFIG.hotkeys)
				.filter(([k]) => k !== 'enabled' && k !== 'navEnabled')
				.map(([k, v]) => `${k}: ${v}`)
				.join(', '));
		}

		teardownHotkeys() {
			if (this._isBound && this._boundHandler) {
				this._listenerTargets.forEach(target => {
					try { target.removeEventListener('keydown', this._boundHandler, this._listenerOptions); } catch {}
				});
				this._isBound = false;
			}
		}

		blockEvent(event) {
			try {
				event.preventDefault();
				event.stopPropagation();
				if (typeof event.stopImmediatePropagation === 'function') {
					event.stopImmediatePropagation();
				}
			} catch {}
		}

		handleKeyDown(event) {
			if (event[EVENT_HANDLED_FLAG]) return;
			event[EVENT_HANDLED_FLAG] = true;

			if (!CONFIG.hotkeys.enabled) return;
			// Âú®ËæìÂÖ•/ÂèØÁºñËæëÂå∫ÂüüÂÜÖ‰∏çËß¶ÂèëÂÖ®Â±ÄÂø´Êç∑ÈîÆ
			try {
				const t = event.target;
				if (t && (t.closest('input, textarea, select, [contenteditable=""], [contenteditable="true"], [role="textbox"]')))
					return;
			} catch {}

			const combo = this.getKeyCombo(event);

			switch (combo) {
				case CONFIG.hotkeys.collapseAll:
					this.blockEvent(event);
					this.collapseManager.collapseAll();
					break;
				case CONFIG.hotkeys.expandAll:
					this.blockEvent(event);
					this.collapseManager.expandAll();
					break;
				case CONFIG.hotkeys.toggleAll:
					this.blockEvent(event);
					this.collapseManager.toggleAll();
					break;
				case CONFIG.hotkeys.showToc:
					this.blockEvent(event);
					this.collapseManager.toggleToc();
					break;
				case CONFIG.hotkeys.search:
					this.blockEvent(event);
					this.collapseManager.toggleSearch();
					break;
				case CONFIG.hotkeys.menu:
					this.blockEvent(event);
					if (this.collapseManager.menuManager) {
						this.collapseManager.menuManager.toggle();
					}
					break;
				case CONFIG.hotkeys.bookmark:
					this.blockEvent(event);
					this.app?.bookmarkManager?.toggleBookmarkForActiveHeader();
					break;
			}

			if (CONFIG.hotkeys.navEnabled) {
				if (combo === CONFIG.hotkeys.nextHeading) {
					this.blockEvent(event);
					this.collapseManager.focusNextHeading();
					return;
				}
				if (combo === CONFIG.hotkeys.prevHeading) {
					this.blockEvent(event);
					this.collapseManager.focusPreviousHeading();
					return;
				}
			}
		}

		getKeyCombo(event) {
			const keys = [];
			const isMac = (() => { try { return /mac/i.test(navigator.platform || navigator.userAgent || ''); } catch { return false; } })();
			if (event.ctrlKey || (isMac && event.metaKey)) keys.push('ctrl');
			if (event.shiftKey) keys.push('shift');
			if (event.altKey) keys.push('alt');
			if (event.metaKey && !isMac) keys.push('meta');

			const key = event.key.toLowerCase();
			if (key !== 'control' && key !== 'shift' && key !== 'alt' && key !== 'meta') {
				keys.push(key);
			}

			return keys.join('+');
		}
	}

	// ÁõÆÂΩïÁîüÊàêÂô®
	class TocGenerator {
		constructor() {
			this.tocContainer = null;
			this.isVisible = false;
			this._keyHandler = null;
			this._idSeed = 0;
			this._scrollHandler = null;
			this._raf = null;
		}

		generateToc() {
			const headers = this.getAllHeaders();
			if (headers.length === 0) return null;

			const toc = document.createElement('div');
			toc.className = CONFIG.classes.tocContainer;
			toc.setAttribute('role', 'dialog');
			toc.setAttribute('aria-modal', 'false');
			toc.setAttribute('aria-label', 'ÁõÆÂΩïÂØºËà™');
			toc.innerHTML = `
				<div class="ghcm-toc-header">
					<h3 id="ghcm-toc-title">üìë ÁõÆÂΩïÂØºËà™</h3>
					<button class="ghcm-toc-close" title="ÂÖ≥Èó≠ÁõÆÂΩï" aria-label="ÂÖ≥Èó≠ÁõÆÂΩï">‚úï</button>
				</div>
				<div class="ghcm-toc-content">
					${this.generateTocItems(headers)}
				</div>
			`;

			this.setupTocEvents(toc);
			return toc;
		}

		getAllHeaders() {
			// Â§çÁî® CollapseManager ÁöÑÊî∂ÈõÜ‰ª•ÂáèÂ∞ëÈáçÂ§çÈÅçÂéÜ
			const source = (this.collapseManager && typeof this.collapseManager.getAllHeaders === 'function')
				? this.collapseManager.getAllHeaders()
				: DOMUtils.collectHeadings();

			const list = source.map(el => ({
				element: el,
				level: DOMUtils.getHeadingLevel(el),
				text: el.textContent.trim(),
				id: this.getHeaderId(el)
			}));

			return this.dedupeById(list);
		}

		// ‰ª• header id ÂéªÈáçÔºåÈÅøÂÖçÈÉ®ÂàÜÈ°µÈù¢ DOM ÁªìÊûÑÈáçÂ§çÊâ´Êèè
		dedupeById(items) {
			try {
				const map = new Map();
				for (const it of items) {
					if (!it || !it.id) continue;
					if (!map.has(it.id)) map.set(it.id, it);
				}
				return Array.from(map.values());
			} catch {
				return items;
			}
		}

		generateTocItems(headers) {
			return headers.map(header => {
				const indent = (header.level - 1) * 20;
				const isCollapsed = header.element.classList.contains(CONFIG.classes.collapsed);
				const collapseIcon = isCollapsed ? '‚ñ∂' : '‚ñº';

				return `
					<div class="ghcm-toc-item" style="padding-left: ${indent}px;" data-level="${header.level}" data-header-id="${header.id}" tabindex="0">
						<span class="ghcm-toc-collapse-icon">${collapseIcon}</span>
						<a href="#${header.id}" class="ghcm-toc-link" data-header-id="${header.id}">
							${header.text}
						</a>
					</div>
				`;
			}).join('');
		}

		getHeaderId(element) {
			// Â∞ùËØïËé∑ÂèñÂ∑≤ÊúâÁöÑID
			const anchor = element.querySelector('.anchor');
			if (anchor) return anchor.getAttribute('href')?.slice(1) || '';

			const id = element.id || element.getAttribute('id');
			if (id) return id;

			// Êó†Áé∞ÊàêIDÔºåÂàôËµã‰∫à‰∏Ä‰∏™Á®≥ÂÆö„ÄÅÂîØ‰∏ÄÁöÑID
			const newId = `ghcm-h-${++this._idSeed}`;
			try { element.setAttribute('id', newId); } catch {}
			return newId;
		}

		getElementPosition(element) {
			let position = 0;
			let current = element;
			while (current && current.parentNode) {
				const siblings = Array.from(current.parentNode.children);
				position += siblings.indexOf(current);
				current = current.parentNode;
			}
			return position;
		}

		setupTocEvents(toc) {
			// ÂÖ≥Èó≠ÊåâÈíÆ
			toc.querySelector('.ghcm-toc-close').addEventListener('click', () => {
				this.hideToc();
			});

			// Êï¥Ë°åÂèØÁÇπÂáªÔºö‰∫ã‰ª∂ÂßîÊâòÂú®ÂÆπÂô®‰∏äÂ§ÑÁêÜ
			toc.addEventListener('click', (e) => {
				const item = e.target.closest('.ghcm-toc-item');
				if (!item) return;
				e.preventDefault();
				const headerId = item.getAttribute('data-header-id') || item.querySelector('.ghcm-toc-link')?.getAttribute('data-header-id');
				if (headerId) this.scrollToHeader(headerId);
			});

			// ÈîÆÁõòÂõûËΩ¶/Á©∫Ê†ºÊøÄÊ¥ªÊï¥Ë°å
			toc.addEventListener('keydown', (e) => {
				if (e.key !== 'Enter' && e.key !== ' ') return;
				const item = e.target.closest('.ghcm-toc-item');
				if (!item) return;
				e.preventDefault();
				const headerId = item.getAttribute('data-header-id') || item.querySelector('.ghcm-toc-link')?.getAttribute('data-header-id');
				if (headerId) this.scrollToHeader(headerId);
			});
		}

		scrollToHeader(headerId) {
			const element = document.getElementById(headerId) ||
							document.querySelector(`[id="${headerId}"]`) ||
							document.querySelector(`#user-content-${headerId}`);

			if (element) {
				// Â¶ÇÊûúÊ†áÈ¢òË¢´ÊäòÂè†ÔºåËá™Âä®Â±ïÂºÄÂÖ∂Áà∂Á∫ß
				this.expandParentHeaders(element);
				// ‰ΩøÁî®Áªü‰∏ÄÊªöÂä®ÂáΩÊï∞ÔºåÈÅøÂÖçÈáçÂ§çÊªöÂä®‰∏éÊäñÂä®
				requestAnimationFrame(() => {
					this.collapseManager.scrollToElement(element);
					this.collapseManager.setActiveHeading(element);
				});
				// Êõ¥Êñ∞ÁõÆÂΩïÊòæÁ§∫Áä∂ÊÄÅ
				setTimeout(() => {
					this.refreshTocStates();
				}, 300);
			}
		}

		// Âà∑Êñ∞ÁõÆÂΩï‰∏≠ÁöÑÊäòÂè†Áä∂ÊÄÅÊòæÁ§∫
		refreshTocStates() {
			if (!this.tocContainer) return;

			const tocItems = this.tocContainer.querySelectorAll('.ghcm-toc-item');
			tocItems.forEach(item => {
				const link = item.querySelector('.ghcm-toc-link');
				const headerId = link.getAttribute('data-header-id');
				const icon = item.querySelector('.ghcm-toc-collapse-icon');

				// Êü•ÊâæÂØπÂ∫îÁöÑÊ†áÈ¢òÂÖÉÁ¥†
				const headerElement = document.getElementById(headerId) ||
									 document.querySelector(`[id="${headerId}"]`) ||
									 document.querySelector(`#user-content-${headerId}`);

				if (headerElement && icon) {
					const isCollapsed = headerElement.classList.contains('ghcm-collapsed');
					icon.textContent = isCollapsed ? '‚ñ∂' : '‚ñº';
				}
			});
		}

		expandParentHeaders(targetElement) {
			// ÊâæÂà∞ÂØπÂ∫îÁöÑcollapseManagerÂÆû‰æãÂπ∂Â±ïÂºÄÂà∞ËØ•Ê†áÈ¢ò
		if (window.ghcmInstance && window.ghcmInstance.collapseManager) {
			window.ghcmInstance.collapseManager.expandToHeader(targetElement, { scroll: false, setActive: false });
		}
		}

		showToc() {
			if (this.tocContainer) {
				this.tocContainer.remove();
			}

			this.tocContainer = this.generateToc();
			if (this.tocContainer) {
				// ÊâìÂºÄÁõÆÂΩïÂâçÂÖ≥Èó≠ÂÖ∂‰ªñÊµÆÂ±Ç
				try { this.collapseManager?.menuManager?.hide(); } catch {}
				try { this.collapseManager?.searchManager?.hideSearch(); } catch {}
				document.body.appendChild(this.tocContainer);
				this.isVisible = true;

				// ESC ÂÖ≥Èó≠
				this._keyHandler = (e) => {
					if (e.key === 'Escape') this.hideToc();
				};
				document.addEventListener('keydown', this._keyHandler);

				// ÂàùÂßãÁÑ¶ÁÇπ
				try { this.tocContainer.setAttribute('tabindex', '-1'); this.tocContainer.focus(); } catch {}

				// Á°Æ‰øùÁä∂ÊÄÅÊ≠£Á°ÆÊòæÁ§∫
				setTimeout(() => {
					this.refreshTocStates();
				}, 100);

				// ÂêØÂä®ÊªöÂä®ÁõëÂê¨ÔºàScroll SpyÔºâ
				this.startScrollSpy();
			}
		}

		hideToc() {
			if (this.tocContainer) {
				this.tocContainer.remove();
				this.tocContainer = null;
				this.isVisible = false;
				if (this._keyHandler) {
					document.removeEventListener('keydown', this._keyHandler);
					this._keyHandler = null;
				}
				this.stopScrollSpy();
			}
		}

		toggle() {
			if (this.isVisible) {
				this.hideToc();
			} else {
				this.showToc();
			}
		}

		// ========= Scroll Spy =========
		startScrollSpy() {
			if (this._scrollHandler) return;
			this._scrollHandler = () => {
				if (this._raf) return;
				this._raf = requestAnimationFrame(() => {
					this._raf = null;
					this.updateActiveFromScroll();
				});
			};
			window.addEventListener('scroll', this._scrollHandler, { passive: true });
			window.addEventListener('resize', this._scrollHandler, { passive: true });
			// ÂàùÊ¨°ËÆ°ÁÆó
			this.updateActiveFromScroll();
		}

		stopScrollSpy() {
			if (!this._scrollHandler) return;
			window.removeEventListener('scroll', this._scrollHandler);
			window.removeEventListener('resize', this._scrollHandler);
			this._scrollHandler = null;
			if (this._raf) { cancelAnimationFrame(this._raf); this._raf = null; }
		}

		updateActiveFromScroll() {
			try {
				const headers = this.getAllHeaders();
				if (!headers.length || !this.tocContainer) return;
				const headerEl = document.querySelector('header[role="banner"], .Header, .AppHeader-globalBar');
				const headerOffset = (headerEl?.offsetHeight || 80) + 20;
				const pos = window.scrollY + headerOffset + 1;
				let active = headers[0];
				for (const h of headers) {
					const rect = h.element.getBoundingClientRect();
					const top = rect.top + window.pageYOffset;
					if (top <= pos) active = h; else break;
				}
				if (active) {
					this.highlightTocById(active.id);
					this.collapseManager?.setActiveHeading(active.element);
				}
			} catch {}
		}

		highlightTocById(id) {
			if (!this.tocContainer) return;
			this.tocContainer.querySelectorAll('.ghcm-toc-item').forEach(el => el.classList.remove('active'));
			const link = this.tocContainer.querySelector(`.ghcm-toc-link[data-header-id="${CSS.escape(id)}"]`);
			if (link) {
				const item = link.closest('.ghcm-toc-item');
				if (item) item.classList.add('active');
			}
		}
	}

	// ÊêúÁ¥¢ÂäüËÉΩ
	class SearchManager {
		constructor(collapseManager) {
			this.collapseManager = collapseManager;
			this.searchContainer = null;
			this.isVisible = false;
			this.activeIndex = -1;
			this._keyHandler = null;
			this._headerIndex = [];
			this._indexDirty = true;
			this._indexSeed = 0;
			this._idMap = new WeakMap();
		}

		invalidateIndex() {
			if (this._headerIndex.length) {
				try {
					this._headerIndex.forEach(item => {
						item?.element?.removeAttribute?.('data-search-id');
					});
				} catch {}
			}
			this._headerIndex = [];
			this._indexDirty = true;
			this._idMap = new WeakMap();
		}

		ensureIndex() {
			if (!this._indexDirty && this._headerIndex.length) {
				return this._headerIndex;
			}

			const elements = DOMUtils.collectHeadings();
			const index = elements.map(el => {
				const existingId = this._idMap.get(el);
				const id = existingId || `search-header-${++this._indexSeed}`;
				this._idMap.set(el, id);
				try { el.setAttribute('data-search-id', id); } catch {}
				return {
					element: el,
					level: DOMUtils.getHeadingLevel(el),
					text: el.textContent.trim(),
					id
				};
			});

			this._headerIndex = index;
			this._indexDirty = false;
			return this._headerIndex;
		}

		createSearchUI() {
			const container = document.createElement('div');
			container.className = CONFIG.classes.searchContainer;
			container.setAttribute('role', 'dialog');
			container.setAttribute('aria-modal', 'true');
			container.setAttribute('aria-label', 'ÊêúÁ¥¢Ê†áÈ¢ò');
			container.innerHTML = `
				<div class="ghcm-search-header">
					<h3 id="ghcm-search-title">üîç ÊêúÁ¥¢Ê†áÈ¢ò</h3>
					<button class="ghcm-search-close" title="ÂÖ≥Èó≠ÊêúÁ¥¢" aria-label="ÂÖ≥Èó≠ÊêúÁ¥¢">‚úï</button>
				</div>
				<div class="ghcm-search-content">
					<input type="text" class="ghcm-search-input" placeholder="ËæìÂÖ•ÂÖ≥ÈîÆËØçÊêúÁ¥¢Ê†áÈ¢ò..." autocomplete="off">
					<div class="ghcm-search-filters">
						<div class="ghcm-level-filters" aria-label="ËøáÊª§Á∫ßÂà´">
							<label><input type="checkbox" data-level="1" checked> H1</label>
							<label><input type="checkbox" data-level="2" checked> H2</label>
							<label><input type="checkbox" data-level="3" checked> H3</label>
							<label><input type="checkbox" data-level="4" checked> H4</label>
							<label><input type="checkbox" data-level="5" checked> H5</label>
							<label><input type="checkbox" data-level="6" checked> H6</label>
						</div>
						<div class="ghcm-search-hint-row">Enter Ë∑≥ËΩ¨ÔºåShift+Enter ‰∏ä‰∏Ä‰∏™</div>
					</div>
					<div class="ghcm-search-results"></div>
				</div>
			`;

			this.setupSearchEvents(container);
			return container;
		}

		setupSearchEvents(container) {
			const input = container.querySelector('.ghcm-search-input');
			const results = container.querySelector('.ghcm-search-results');
			const closeBtn = container.querySelector('.ghcm-search-close');
            const levelBox = container.querySelector('.ghcm-level-filters');

            // Á∫ßÂà´ËøáÊª§ÈªòËÆ§ÂÖ®ÈÉ®ÂêØÁî®
            this.levelFilter = new Set([1,2,3,4,5,6]);

			// ÂÆûÊó∂ÊêúÁ¥¢
			let searchTimeout;
			input.addEventListener('input', () => {
				clearTimeout(searchTimeout);
				searchTimeout = setTimeout(() => {
					this.performSearch(input.value.trim(), results);
				}, 300);
			});

			// Á∫ßÂà´ËøáÊª§ÂèòÊõ¥
			levelBox.addEventListener('change', (e) => {
				const cb = e.target.closest('input[type="checkbox"][data-level]');
				if (!cb) return;
				const lvl = parseInt(cb.getAttribute('data-level'), 10);
				if (cb.checked) this.levelFilter.add(lvl); else this.levelFilter.delete(lvl);
				this.performSearch(input.value.trim(), results);
			});

			// ÂÖ≥Èó≠ÊêúÁ¥¢
			closeBtn.addEventListener('click', () => {
				this.hideSearch();
			});

			// ÊêúÁ¥¢ÁªìÊûúÁÇπÂáªÂßîÊâò
			results.addEventListener('click', (event) => {
				const item = event.target.closest('.ghcm-search-result');
				if (!item) return;
				const headerId = item.getAttribute('data-header-element');
				if (headerId) {
					this.jumpToHeader(headerId);
				}
			});

			results.addEventListener('focusin', (event) => {
				const item = event.target.closest('.ghcm-search-result');
				if (!item) return;
				const items = Array.from(results.querySelectorAll('.ghcm-search-result'));
				const idx = items.indexOf(item);
				if (idx !== -1) {
					this.activeIndex = idx;
					this.updateActiveResult(items);
				}
			});

			// ÈîÆÁõòÂØºËà™‰∏é ESC ÂÖ≥Èó≠
			this._keyHandler = (e) => {
				if (e.key === 'Escape') {
					this.hideSearch();
					return;
				}
				if (e.key === 'Tab') {
					const focusables = this.getSearchFocusables(container);
					const current = document.activeElement;
					const idx = focusables.indexOf(current);
					if (idx !== -1 && focusables.length > 0) {
						e.preventDefault();
						const nextIndex = (idx + (e.shiftKey ? -1 : 1) + focusables.length) % focusables.length;
						const target = focusables[nextIndex];
						target?.focus();
						if (target?.classList?.contains('ghcm-search-result')) {
							const items = Array.from(results.querySelectorAll('.ghcm-search-result'));
							const focusIdx = items.indexOf(target);
							if (focusIdx !== -1) {
								this.activeIndex = focusIdx;
								this.updateActiveResult(items);
							}
						}
					}
					return;
				}
				const items = Array.from(results.querySelectorAll('.ghcm-search-result'));
				if (items.length === 0) return;
				if (e.key === 'ArrowDown') {
					e.preventDefault();
					this.activeIndex = (this.activeIndex + 1) % items.length;
					this.updateActiveResult(items);
				} else if (e.key === 'ArrowUp') {
					e.preventDefault();
					this.activeIndex = (this.activeIndex - 1 + items.length) % items.length;
					this.updateActiveResult(items);
				} else if (e.key === 'Enter') {
					if (this.activeIndex >= 0 && this.activeIndex < items.length) {
						if (e.shiftKey) {
							// Shift+Enter ‰∏ä‰∏Ä‰∏™
							this.activeIndex = (this.activeIndex - 1 + items.length) % items.length;
							this.updateActiveResult(items);
						} else {
							items[this.activeIndex].click();
						}
					}
				}
			};
			container.addEventListener('keydown', this._keyHandler);

			// Ëá™Âä®ËÅöÁÑ¶
			setTimeout(() => input.focus(), 100);
		}

		updateActiveResult(items) {
			items.forEach((el, i) => el.classList.toggle('active', i === this.activeIndex));
			if (this.activeIndex >= 0 && items[this.activeIndex]) {
				items[this.activeIndex].scrollIntoView({ block: 'nearest' });
			}
		}

		getSearchFocusables(container) {
			const focusables = [];
			const input = container.querySelector('.ghcm-search-input');
			if (input) focusables.push(input);
			focusables.push(...Array.from(container.querySelectorAll('.ghcm-level-filters input[type="checkbox"]')));
			focusables.push(...Array.from(container.querySelectorAll('.ghcm-search-result')));
			const closeBtn = container.querySelector('.ghcm-search-close');
			if (closeBtn) focusables.push(closeBtn);
			return focusables;
		}

		performSearch(query, resultsContainer) {
			if (!query) {
				resultsContainer.innerHTML = '<div class="ghcm-search-hint">ËØ∑ËæìÂÖ•ÊêúÁ¥¢ÂÖ≥ÈîÆËØç</div>';
				this.activeIndex = -1;
				return;
			}

			const headers = this.getAllSearchableHeaders();
			// Á∫ßÂà´ËøáÊª§
			const filtered = headers.filter(h => this.levelFilter?.has(h.level));
			// Ê®°Á≥äÂåπÈÖç + ÊâìÂàÜ
			const q = query.trim();
			const matches = [];
			for (const h of filtered) {
				const res = this.fuzzyMatch(h.text, q);
				if (res.matched) {
					matches.push({ h, score: res.score, indices: res.indices });
				}
			}
			matches.sort((a,b) => b.score - a.score);

			if (matches.length === 0) {
				resultsContainer.innerHTML = '<div class="ghcm-search-no-results">Êú™ÊâæÂà∞ÂåπÈÖçÁöÑÊ†áÈ¢ò</div>';
				this.activeIndex = -1;
				return;
			}

			const resultHtml = matches.map(({h, indices}) => `
				<div class="ghcm-search-result" data-header-element="${h.id}" tabindex="0">
					<span class="ghcm-search-level">H${h.level}</span>
					<span class="ghcm-search-text">${this.safeHighlightByIndices(h.text, indices)}</span>
				</div>
			`).join('');

			resultsContainer.innerHTML = resultHtml;
			const items = Array.from(resultsContainer.querySelectorAll('.ghcm-search-result'));
			if (items.length) {
				this.activeIndex = 0;
				this.updateActiveResult(items);
			} else {
				this.activeIndex = -1;
			}
		}

		// ÁÆÄÂçïÊ®°Á≥äÂåπÈÖçÔºö
		// 1) ËøûÁª≠Â≠ê‰∏≤ÂåπÈÖçÁªôÈ´òÂàÜÔºõ2) ÊåâÂ≠óÁ¨¶È°∫Â∫èÂåπÈÖçÊúâÊÉ©ÁΩöÔºõ3) ËÆ∞ÂΩïÂëΩ‰∏≠Á¥¢ÂºïÁî®‰∫éÈ´ò‰∫Æ
		fuzzyMatch(text, query) {
			const t = (text || '').toLowerCase();
			const q = (query || '').toLowerCase();
			if (!q) return { matched: true, score: 0, indices: [] };
			const i = t.indexOf(q);
			if (i !== -1) {
				const indices = Array.from({length: q.length}, (_,k)=> i+k);
				const score = 1000 - i; // Ë∂äÈù†ÂâçË∂äÈ´òÂàÜ
				return { matched: true, score, indices };
			}
			// È°∫Â∫èÂ≠êÂ∫èÂàóÂåπÈÖç
			let ti = 0; const indices = [];
			for (let qi = 0; qi < q.length; qi++) {
				const ch = q[qi];
				ti = t.indexOf(ch, ti);
				if (ti === -1) return { matched: false, score: -Infinity, indices: [] };
				indices.push(ti);
				ti++;
			}
			// ËØÑÂàÜÔºöË∂äËøûÁª≠„ÄÅË∑®Â∫¶Ë∂äÂ∞èÂæóÂàÜË∂äÈ´ò
			let gaps = 0; for (let k=1;k<indices.length;k++){ gaps += (indices[k]-indices[k-1]-1); }
			const span = indices[indices.length-1] - indices[0] + 1;
			const score = 500 - gaps*5 - span;
			return { matched: true, score, indices };
		}

		safeHighlightByIndices(text, indices) {
			try {
				if (!indices || !indices.length) return this.safeHighlightMatch(text, '');
				let out = '';
				let last = 0;
				const set = new Set(indices);
				for (let i=0;i<text.length;i++) {
					if (set.has(i)) {
						// ÂºÄÂßãÊ†áËÆ∞ËøûÁª≠ÊÆµ
						let j = i;
						while (set.has(j)) j++;
						out += this.escapeHtml(text.slice(last, i)) + '<mark>' + this.escapeHtml(text.slice(i, j)) + '</mark>';
						last = j; i = j-1;
					}
				}
				out += this.escapeHtml(text.slice(last));
				return out;
			} catch { return this.escapeHtml(String(text||'')); }
		}

		escapeHtml(s){
			return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
		}

		getAllSearchableHeaders() {
			return this.ensureIndex();
		}

		highlightMatch(text, query) {
			const escaped = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			const regex = new RegExp(`(${escaped})`, 'gi');
			return text.replace(regex, '<mark>$1</mark>');
		}

		safeHighlightMatch(text, query) {
			try {
				const escaped = String(query).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
				const regex = new RegExp(`(${escaped})`, 'gi');
				return String(text).replace(regex, '<mark>$1</mark>');
			} catch (e) {
				return text;
			}
		}

		jumpToHeader(headerId) {
			const element = document.querySelector(`[data-search-id="${headerId}"]`);
			if (element) {
				// Â±ïÂºÄÂà∞ËØ•Ê†áÈ¢ò
				this.collapseManager.expandToHeader(element, { scroll: false, setActive: false });
				this.collapseManager.scrollToElement(element);
				this.collapseManager.setActiveHeading(element);
				// ÈöêËóèÊêúÁ¥¢ÁïåÈù¢
				this.hideSearch();
			}
		}

		showSearch() {
			if (this.searchContainer) {
				this.searchContainer.remove();
			}

			// ÊâìÂºÄÊêúÁ¥¢ÂâçÂÖ≥Èó≠ÂÖ∂‰ªñÊµÆÂ±Ç
			try { this.collapseManager?.menuManager?.hide(); } catch {}
			try { this.collapseManager?.tocGenerator?.hideToc(); } catch {}

			this.searchContainer = this.createSearchUI();
			document.body.appendChild(this.searchContainer);
			this.isVisible = true;
		}

		hideSearch() {
			if (this.searchContainer) {
				this.searchContainer.remove();
				this.searchContainer = null;
				this.isVisible = false;
				// Ê∏ÖÁêÜÈîÆÁõò‰∫ã‰ª∂
				if (this._keyHandler) {
					// ÁªëÂÆöÂú®ÂÆπÂô®‰∏äÔºåÂÆπÂô®Â∑≤ÁßªÈô§Âç≥ÂèØ
					this._keyHandler = null;
				}
				this.activeIndex = -1;
			}
		}

		toggle() {
			if (this.isVisible) {
				this.hideSearch();
			} else {
				this.showSearch();
			}
		}
	}

	class BookmarkManager {
		constructor(app) {
			this.app = app;
			this.storageKey = CONFIG.bookmarks.key;
			this.bookmarksByPage = this.normalizeStoredBookmarks(GM_getValue(this.storageKey, null));
			this._applyRetryTimer = null;
			this._applyRetryAttempts = 0;
			this._applyRetryMax = 6;
			this._applyRetryDelay = 300;
			this.ensurePageEntry();
			setTimeout(() => this.applyBookmarks(), 200);
		}

		getPageKey() {
			return this.app.stateManager.pageUrl;
		}

		normalizeStoredBookmarks(raw) {
			if (!raw) return {};
			let data = raw;
			if (typeof raw === 'string') {
				try {
					data = JSON.parse(raw);
				} catch {
					return {};
				}
			}
			if (!data || typeof data !== 'object') return {};
			const normalized = {};
			Object.entries(data).forEach(([pageKey, entries]) => {
				if (!Array.isArray(entries)) return;
				const cleaned = entries
					.map(entry => this.cloneBookmark(entry))
					.filter(Boolean);
				if (cleaned.length) {
					normalized[pageKey] = cleaned;
				}
			});
			return normalized;
		}

		sanitizeBookmark(entry) {
			if (!entry || typeof entry !== 'object') return null;
			const key = typeof entry.key === 'string' ? entry.key.trim() : '';
			if (!key) return null;
			const sanitized = { key };
			if (typeof entry.id === 'string' && entry.id.trim()) {
				sanitized.id = entry.id.trim();
			}
			if (typeof entry.text === 'string') {
				sanitized.text = entry.text;
			}
			if (typeof entry.level === 'number' && entry.level >= 1 && entry.level <= 6) {
				sanitized.level = entry.level;
			}
			return sanitized;
		}

		cloneBookmark(entry) {
			const sanitized = this.sanitizeBookmark(entry);
			return sanitized ? { ...sanitized } : null;
		}

		serializeBookmarks() {
			const snapshot = {};
			Object.entries(this.bookmarksByPage).forEach(([pageKey, entries]) => {
				if (!Array.isArray(entries) || entries.length === 0) return;
				const cleaned = entries
					.map(entry => this.sanitizeBookmark(entry))
					.filter(Boolean);
				if (cleaned.length) {
					snapshot[pageKey] = cleaned;
				}
			});
			return JSON.stringify(snapshot);
		}

		ensurePageEntry() {
			const key = this.getPageKey();
			if (!Array.isArray(this.bookmarksByPage[key])) {
				this.bookmarksByPage[key] = [];
			}
			this.bookmarksByPage[key] = this.bookmarksByPage[key]
				.map(entry => this.cloneBookmark(entry))
				.filter(Boolean);
			return this.bookmarksByPage[key];
		}

		getBookmarksForCurrentPage() {
			return this.ensurePageEntry().map(entry => this.cloneBookmark(entry)).filter(Boolean);
		}

		save() {
			try {
				GM_setValue(this.storageKey, this.serializeBookmarks());
			} catch (e) {
				Logger.warn('[GHCM] ‰øùÂ≠ò‰π¶Á≠æÂ§±Ë¥•:', e);
			}
		}

		getHeaderElement(node) {
			if (!node) return null;
			if (DOMUtils.isHeader(node)) return node;
			let header = null;
			try {
				if (typeof node.closest === 'function') {
					header = node.closest(DOMUtils.getUpperHeadingSelector());
				}
			} catch {}
			if (header && DOMUtils.isHeader(header)) return header;
			try {
				const wrapper = node.closest?.('.markdown-heading');
				if (wrapper) {
					header = wrapper.querySelector(DOMUtils.getUpperHeadingSelector());
				}
			} catch {}
			return (header && DOMUtils.isHeader(header)) ? header : null;
		}

		ensureHeaderId(element) {
			const header = this.getHeaderElement(element) || element;
			if (!header) return null;
			const normalize = value => (typeof value === 'string' ? value.trim() : '');

			const directId = normalize(header.getAttribute?.('id') || header.id);
			if (directId && !/^ghcm-(?:bookmark|h)-/i.test(directId)) {
				return directId;
			}

			try {
				if (this.app.tocGenerator && typeof this.app.tocGenerator.getHeaderId === 'function') {
					const tocId = normalize(this.app.tocGenerator.getHeaderId(header));
					if (tocId) return tocId;
				}
			} catch {}

			let anchorId = '';
			let hrefId = '';
			try {
				const anchor = header.querySelector?.('.anchor');
				if (anchor) {
					anchorId = normalize(anchor.getAttribute('id'));
					hrefId = normalize(anchor.getAttribute('href')?.replace(/^#/, ''));
				}
			} catch {}
			if (anchorId) return anchorId;
			if (hrefId) return hrefId;

			let childId = '';
			try {
				const anyWithId = header.querySelector?.('[id]');
				childId = normalize(anyWithId?.getAttribute('id'));
			} catch {}
			if (childId) return childId;

			const generated = `ghcm-bookmark-${Date.now()}-${Math.random().toString(36).slice(2)}`;
			try { header.setAttribute('id', generated); } catch {}
			return generated;
		}

		addBookmarkForElement(element, { notify = true } = {}) {
			const header = this.getHeaderElement(element) || element;
			if (!header || !DOMUtils.isHeader(header)) return;
			const pageBookmarks = this.ensurePageEntry();
			const key = this.app.stateManager.generateHeaderKey(header);
			const existingIndex = pageBookmarks.findIndex(item => item.key === key);
			if (existingIndex !== -1) {
				if (notify) this.app.collapseManager.showNotification('‚≠ê ËØ•Ê†áÈ¢òÂ∑≤Âú®‰π¶Á≠æ‰∏≠');
				return;
			}
			const id = this.ensureHeaderId(header);
			this.app.collapseManager.setActiveHeading(header);
			const entry = {
				id,
				key,
				text: header.textContent?.trim() || 'Êú™ÂëΩÂêçÊ†áÈ¢ò',
				level: DOMUtils.getHeadingLevel(header)
			};
			pageBookmarks.push(entry);
			this.save();
			this.applyBookmarks();
			if (notify) this.app.collapseManager.showNotification('‚≠ê Â∑≤Êî∂ËóèÂΩìÂâçÊ†áÈ¢ò');
			this.app.menuManager?.updateBookmarkList();
		}

			toggleBookmarkForElement(element) {
				const header = this.getHeaderElement(element) || element;
				if (!header || !DOMUtils.isHeader(header)) return;
				this.app.collapseManager.setActiveHeading(header);
				const pageBookmarks = this.ensurePageEntry();
				const key = this.app.stateManager.generateHeaderKey(header);
			const existingIndex = pageBookmarks.findIndex(item => item.key === key);
			if (existingIndex !== -1) {
				pageBookmarks.splice(existingIndex, 1);
				this.save();
				this.applyBookmarks();
				this.app.collapseManager.showNotification('üóëÔ∏è Â∑≤ÁßªÈô§‰π¶Á≠æ');
				this.app.menuManager?.updateBookmarkList();
				return;
			}
			this.addBookmarkForElement(header);
		}

			toggleBookmarkForActiveHeader() {
				let header = DOMUtils.getHeaderFromSelection();
				if (!header) {
					header = this.app.collapseManager.getActiveHeaderElement();
				}
				if (!header) {
					header = this.app.collapseManager.getActiveHeaderElement(true);
				}
				if (!header) {
					this.app.collapseManager.showNotification('‚ö†Ô∏è Êú™ÊâæÂà∞ÂèØÊî∂ËóèÁöÑÊ†áÈ¢ò');
					return;
				}
				this.app.collapseManager.setActiveHeading(header);
				this.toggleBookmarkForElement(header);
			}

			addBookmarkFromViewport() {
				let header = DOMUtils.getHeaderFromSelection();
				if (!header) {
					header = this.app.collapseManager.getActiveHeaderElement();
				}
				if (!header) {
					header = this.app.collapseManager.getActiveHeaderElement(true);
				}
				if (!header) {
					this.app.collapseManager.showNotification('‚ö†Ô∏è ÂΩìÂâçËßÜÂõæÊú™ÊâæÂà∞Ê†áÈ¢ò');
					return;
			}
			this.app.collapseManager.setActiveHeading(header);
			this.addBookmarkForElement(header);
		}

		removeBookmarkByIndex(index) {
			const pageBookmarks = this.ensurePageEntry();
			if (index < 0 || index >= pageBookmarks.length) return;
			pageBookmarks.splice(index, 1);
			this.save();
			this.applyBookmarks();
			this.app.collapseManager.showNotification('üóëÔ∏è Â∑≤ÁßªÈô§‰π¶Á≠æ');
			this.app.menuManager?.updateBookmarkList();
		}

		clearPageBookmarks() {
			const key = this.getPageKey();
			this.bookmarksByPage[key] = [];
			this.save();
			this.applyBookmarks();
			this.app.collapseManager.showNotification('üóÇÔ∏è Â∑≤Ê∏ÖÁ©∫Êú¨È°µ‰π¶Á≠æ');
			this.app.menuManager?.updateBookmarkList();
		}

			openBookmarkByIndex(index) {
				const pageBookmarks = this.ensurePageEntry();
				if (index < 0 || index >= pageBookmarks.length) return;
				const bookmark = pageBookmarks[index];
				const element = this.resolveBookmarkElement(bookmark);
			if (element) {
				this.app.collapseManager.expandToHeader(element, { scroll: false, setActive: false });
				this.app.collapseManager.scrollToElement(element);
				this.app.collapseManager.setActiveHeading(element);
				this.highlightTemporarily(element);
			}
		}

		resolveBookmarkElement(bookmark) {
			if (!bookmark) return null;
			const candidates = [];
			if (typeof bookmark.id === 'string' && bookmark.id.trim()) {
				const trimmed = bookmark.id.trim();
				candidates.push(trimmed);
				if (!trimmed.startsWith('user-content-')) {
					candidates.push(`user-content-${trimmed}`);
				}
			}

			let element = null;
			for (const candidate of candidates) {
				if (!candidate) continue;
				let found = null;
				try { found = document.getElementById(candidate); } catch {}
				if (!found) continue;
				const header = this.getHeaderElement(found);
				if (header) {
					element = header;
					break;
				}
			}

			if (!element) {
				const headers = this.app.collapseManager.getAllHeaders();
				for (const header of headers) {
					const key = this.app.stateManager.generateHeaderKey(header);
					if (key === bookmark.key) {
						element = header;
						break;
					}
				}
			}

			if (!element) return null;

			const newId = this.ensureHeaderId(element);
			if (newId && newId !== bookmark.id) {
				bookmark.id = newId;
				this.save();
			}
			return element;
		}

		applyBookmarks({ attempt = 0 } = {}) {
			const headers = this.app.collapseManager.getAllHeaders();
			headers.forEach(header => header.classList.remove(CONFIG.classes.bookmarked));
			const pageKey = this.getPageKey();
			const pageBookmarks = this.ensurePageEntry();
			let unresolved = 0;
			pageBookmarks.forEach(bookmark => {
				const element = this.resolveBookmarkElement(bookmark);
				if (element) {
					element.classList.add(CONFIG.classes.bookmarked);
				} else {
					unresolved++;
				}
			});

			if (unresolved > 0 && attempt < this._applyRetryMax) {
				if (this._applyRetryTimer) clearTimeout(this._applyRetryTimer);
				const nextAttempt = attempt + 1;
				this._applyRetryAttempts = nextAttempt;
				this._applyRetryTimer = setTimeout(() => {
					this._applyRetryTimer = null;
					this.applyBookmarks({ attempt: nextAttempt });
				}, this._applyRetryDelay);
			} else if (unresolved === 0) {
				this._applyRetryAttempts = 0;
				if (this._applyRetryTimer) {
					clearTimeout(this._applyRetryTimer);
					this._applyRetryTimer = null;
				}
			} else if (unresolved > 0) {
				this._applyRetryAttempts = 0;
				if (this._applyRetryTimer) {
					clearTimeout(this._applyRetryTimer);
					this._applyRetryTimer = null;
				}
			}

			this.app.menuManager?.updateBookmarkList();
		}

			highlightTemporarily(element) {
			if (!element) return;
			try {
				element.classList.add('ghcm-temp-highlight');
				setTimeout(() => element.classList.remove('ghcm-temp-highlight'), 600);
			} catch {}
		}
	}

	// DOM Â∑•ÂÖ∑Á±ª
	class DOMUtils {
		static getHeadingTagsLower() {
			if (!DOMUtils._headingTagsLower) {
				DOMUtils._headingTagsLower = CONFIG.selectors.headers.map(tag => tag.toLowerCase());
			}
			return DOMUtils._headingTagsLower;
		}

		static getUpperHeadingSelector() {
			if (!DOMUtils._upperHeadingSelector) {
				DOMUtils._upperHeadingSelector = CONFIG.selectors.headers.join(',');
			}
			return DOMUtils._upperHeadingSelector;
		}

		static getHeadingTags({ level, upToLevel } = {}) {
			const tags = DOMUtils.getHeadingTagsLower();
			if (typeof level === 'number') {
				const tag = tags[level - 1];
				return tag ? [tag] : [];
			}
			if (typeof upToLevel === 'number') {
				return tags.slice(0, upToLevel);
			}
			return tags;
		}

		static getCachedSelector(key, builder) {
			if (!DOMUtils._selectorCache) {
				DOMUtils._selectorCache = new Map();
			}
			if (!DOMUtils._selectorCache.has(key)) {
				DOMUtils._selectorCache.set(key, builder());
			}
			return DOMUtils._selectorCache.get(key);
		}

		static buildSelector(tags, { scopedTo, includeWrapper } = {}) {
			if (!tags || !tags.length) return '';
			const selectors = [];
			tags.forEach(tag => {
				const base = scopedTo ? `${scopedTo} ${tag}` : tag;
				selectors.push(base);
				if (includeWrapper) {
					selectors.push(`${base}.heading-element`);
				}
			});
			return selectors.join(', ');
		}

		static getHeadingSelector() {
			return DOMUtils.getCachedSelector('all-headings', () =>
				DOMUtils.buildSelector(DOMUtils.getHeadingTags())
			);
		}

		static getHeadingSelectorUpToLevel(level) {
			return DOMUtils.getCachedSelector(`upto-${level}`, () =>
				DOMUtils.buildSelector(DOMUtils.getHeadingTags({ upToLevel: level }))
			);
		}

		static getScopedHeadingSelector(container, { includeWrapper = false, level, upToLevel } = {}) {
			if (!container) return '';
			const key = `scope-${container}|wrap:${includeWrapper}|level:${level ?? 'all'}|upto:${upToLevel ?? 'na'}`;
			return DOMUtils.getCachedSelector(key, () =>
				DOMUtils.buildSelector(
					DOMUtils.getHeadingTags({ level, upToLevel }),
					{ scopedTo: container, includeWrapper }
				)
			);
		}

		static collectHeadings(containers = CONFIG.selectors.markdownContainers) {
			const useCache = containers === CONFIG.selectors.markdownContainers;
			if (useCache && DOMUtils._headingCache) {
				return DOMUtils._headingCache.slice();
			}

			const selectors = containers
				.map(container => DOMUtils.getScopedHeadingSelector(container))
				.filter(Boolean);
			if (!selectors.length) return [];
			try {
				const list = DOMUtils.$$(selectors.join(', '))
					.filter(element => DOMUtils.shouldIncludeHeading(element));
				if (useCache) {
					DOMUtils._headingCache = list;
					return list.slice();
				}
				return list;
			} catch {
				return [];
			}
		}

		static hasMarkdownHeadings() {
			return CONFIG.selectors.markdownContainers.some(container => {
				try {
					const selector = DOMUtils.getScopedHeadingSelector(container);
					return selector ? !!document.querySelector(selector) : false;
				} catch {
					return false;
				}
			});
		}

		static getHeadingLevel(element) {
			if (!element || !element.nodeName) return 0;
			const match = element.nodeName.match(/h([1-6])/i);
			return match ? parseInt(match[1], 10) : 0;
		}

		static $(selector, parent = document) {
			return parent.querySelector(selector);
		}

		static $$(selector, parent = document) {
			return Array.from(parent.querySelectorAll(selector));
		}

		static isHeader(element) {
			return CONFIG.selectors.headers.includes(element.nodeName);
		}

		static isInMarkdown(element) {
			return CONFIG.selectors.markdownContainers.some(selector =>
				element.closest(selector)
			);
		}

		static getHeaderContainer(header) {
			return header.closest('.markdown-heading') || header;
		}

		static clearSelection() {
			const selection = window.getSelection?.() || document.selection;
			if (selection) {
				if (selection.removeAllRanges) {
					selection.removeAllRanges();
				} else if (selection.empty) {
					selection.empty();
				}
			}
		}

		static blurActiveElement() {
			try {
				const active = document.activeElement;
				if (!active || active === document.body) return;
				if (typeof active.blur === 'function') {
					active.blur();
				}
			} catch {}
		}

		static getHeaderFromSelection() {
			try {
				const selection = window.getSelection?.();
				if (!selection || selection.rangeCount === 0) return null;
				const node = selection.focusNode || selection.anchorNode;
				if (!node) return null;
				const isElementNode = typeof Node !== 'undefined' && node.nodeType === Node.ELEMENT_NODE;
				const element = (isElementNode ? node : node.parentElement) || null;
				if (!element) return null;
				const direct = element.closest(DOMUtils.getUpperHeadingSelector());
				if (direct && DOMUtils.shouldIncludeHeading(direct)) {
					return direct;
				}
				const wrapper = element.closest('.markdown-heading');
				if (wrapper) {
					const header = wrapper.querySelector(DOMUtils.getUpperHeadingSelector());
					if (header && DOMUtils.shouldIncludeHeading(header)) {
						return header;
					}
				}
			} catch {}
			return null;
		}

		// ‰ªÖÊî∂ÂΩïÈ°µÈù¢‰∏≠ÂèØËßÅ‰∏îÈùûËæÖÂä©ÂØºËà™Âå∫ÂüüÁöÑÊ†áÈ¢ò
		static isVisible(el) {
			try {
				if (!el || el.getAttribute('aria-hidden') === 'true' || el.hidden) return false;
				// Â∏∏ËßÅ SR-only Á±ª
				const cls = el.className || '';
				if (typeof cls === 'string' && /(sr-only|visually-hidden)/i.test(cls)) return false;
				// ËÆ°ÁÆóÂèØËßÅÊÄß
				const rects = el.getClientRects?.();
				if (!rects || rects.length === 0) return false;
				return (el.offsetWidth + el.offsetHeight) > 0;
			} catch { return true; }
		}

		static inIgnoredRegion(el) {
			try {
				return !!el.closest('nav, header, footer, aside, [role="navigation"], [role="menu"], [role="menubar"], [role="toolbar"]');
			} catch { return false; }
		}

		static shouldIncludeHeading(el) {
			if (!DOMUtils.isHeader(el)) return false;
			if (!DOMUtils.isInMarkdown(el)) return false;
			if (DOMUtils.inIgnoredRegion(el)) return false;
			if (!DOMUtils.isVisible(el)) return false;
			return true;
		}

		static invalidateHeadingCache() {
			DOMUtils._headingCache = null;
		}
	}

	// Ê†∑ÂºèÁÆ°ÁêÜÂô®
	class StyleManager {
		constructor() {
			this.arrowColors = document.createElement("style");
			this.arrowContentOverride = document.createElement("style");
			this.init();
		}

			init() {
				this.addBaseStyles();
				this.addColorStyles();
				document.head.appendChild(this.arrowColors);
				// ÂàùÂßãÁÆ≠Â§¥ÂÜÖÂÆπË¶ÜÁõñÔºàÁî®‰∫é‚Äú‰ªÖÊòæÁ§∫ÁÆ≠Â§¥‚ÄùÂºÄÂÖ≥Ôºâ
				document.head.appendChild(this.arrowContentOverride);
				this.updateArrowContentOverride();
				this.applyArrowSize(CONFIG.ui.arrowSize);
			}

		addBaseStyles() {
			const headerSelectors = this.generateHeaderSelectors();

	GM_addStyle(`
				/* Âü∫Á°ÄÊ†∑Âºè */
				${headerSelectors.base} {
			position: relative;
			padding-right: 3em;
			cursor: pointer;
					transition: all ${CONFIG.animation.duration}ms ${CONFIG.animation.easing};
				}

				/* ÁÆ≠Â§¥ÊåáÁ§∫Âô® */
				${headerSelectors.after} {
			display: inline-block;
				position: absolute;
			right: 0.5em;
						top: 50%;
						transform: translateY(-50%);
				font-size: var(--ghcm-arrow-size, 0.8em);
						font-weight: bold;
						pointer-events: none;
						transition: transform ${CONFIG.animation.duration}ms ${CONFIG.animation.easing};
				}

				/* ÂêÑÁ∫ßÊ†áÈ¢òÁöÑÁÆ≠Â§¥ÂÜÖÂÆπ */
				${this.generateArrowContent()}

					/* ÊäòÂè†Áä∂ÊÄÅÁöÑÁÆ≠Â§¥ÊóãËΩ¨ */
					.${CONFIG.classes.collapsed}:after {
						transform: translateY(-50%) rotate(-90deg);
					}

					/* ‰π¶Á≠æÊ†áËÆ∞ */
					.${CONFIG.classes.bookmarked} {
						background: rgba(252, 211, 77, 0.35);
						border-radius: 4px;
					}

					.${CONFIG.classes.bookmarked}::before {
						content: none;
					}

					/* ÂΩìÂâçÊøÄÊ¥ªÊ†áÈ¢ò */
					.${CONFIG.classes.activeHeading} {
						background: rgba(191, 219, 254, 0.55);
						border-radius: 4px;
					}

					.${CONFIG.classes.bookmarked}.${CONFIG.classes.activeHeading} {
						background: rgba(224, 231, 255, 0.6);
					}

					.${CONFIG.classes.hoverHeading} {
						background: rgba(107, 114, 128, 0.12);
						border-radius: 4px;
					}

					.ghcm-temp-highlight {
						background: rgba(191, 219, 254, 0.4);
						transition: background 0.4s ease;
					}

					/* ÈöêËóèÂÖÉÁ¥† */
				.${CONFIG.classes.hidden},
				.${CONFIG.classes.hiddenByParent} {
					display: none !important;
					opacity: 0 !important;
				}

				/* Êó†ÂÜÖÂÆπÊ†áÈ¢ò */
				.${CONFIG.classes.noContent}:after {
					display: none !important;
				}

				/* ‰øùÁïô GitHub Ê†áÈ¢òÈîöÁÇπ‰∫§‰∫íÔºå‰∏çÁ¶ÅÊ≠¢ÁÇπÂáª */

				/* Âπ≥ÊªëÂä®Áîª */
				.ghcm-transitioning {
					transition: opacity ${CONFIG.animation.duration}ms ${CONFIG.animation.easing},
					           transform ${CONFIG.animation.duration}ms ${CONFIG.animation.easing};
				}

				/* ÁõÆÂΩïÂÆπÂô®Ê†∑Âºè */
				.${CONFIG.classes.tocContainer} {
					position: fixed;
					top: 20px;
					right: 20px;
					width: 300px;
					max-height: 70vh;
					background: var(--color-canvas-default, #ffffff);
					border: 1px solid var(--color-border-default, #d0d7de);
					border-radius: 8px;
					box-shadow: 0 8px 24px rgba(0,0,0,0.12);
					z-index: 10000;
					overflow: hidden;
					font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
				}

				.ghcm-toc-header {
					padding: 8px 12px;
					background: var(--color-canvas-subtle, #f6f8fa);
					border-bottom: 1px solid var(--color-border-default, #d0d7de);
					display: flex;
					justify-content: space-between;
					align-items: center;
					min-height: 36px;
				}

				.ghcm-toc-header h3 {
					margin: 0;
					font-size: 13px;
					font-weight: 600;
					color: var(--color-fg-default, #24292f);
					line-height: 1.2;
				}

				.ghcm-toc-close {
					background: none;
					border: none;
					font-size: 14px;
					cursor: pointer;
					padding: 2px 4px;
					border-radius: 3px;
					color: var(--color-fg-muted, #656d76);
					line-height: 1;
				}

				.ghcm-toc-close:hover {
					background: var(--color-danger-subtle, #ffebe9);
					color: var(--color-danger-fg, #cf222e);
				}

				.ghcm-toc-content {
					max-height: calc(70vh - 44px);
					overflow-y: auto;
					padding: 6px 0;
				}

				.ghcm-toc-item {
					display: flex;
					align-items: center;
					padding: 4px 16px;
					border-radius: 4px;
					margin: 1px 8px;
					cursor: pointer;
				}

				.ghcm-toc-item:hover {
					background: var(--color-neutral-subtle, #f6f8fa);
				}

				/* TOC Ê¥ªÂä®È´ò‰∫Æ */
				.ghcm-toc-item.active {
					background: var(--color-accent-subtle, #ddf4ff);
				}
				.ghcm-toc-item.active .ghcm-toc-link {
					color: var(--color-accent-fg, #0969da);
					font-weight: 600;
				}

				.ghcm-toc-collapse-icon {
					font-size: 10px;
					margin-right: 8px;
					color: var(--color-fg-muted, #656d76);
					min-width: 12px;
				}

				.ghcm-toc-link {
					text-decoration: none;
					color: var(--color-fg-default, #24292f);
					font-size: 13px;
					line-height: 1.4;
					flex: 1;
				}

				.ghcm-toc-link:hover {
					color: var(--color-accent-fg, #0969da);
				}

				/* ÊêúÁ¥¢ÂÆπÂô®Ê†∑Âºè */
				.${CONFIG.classes.searchContainer} {
					position: fixed;
					top: 50%;
					left: 50%;
					transform: translate(-50%, -50%);
					width: 480px;
					max-width: 90vw;
					max-height: 80vh;
					background: var(--color-canvas-default, #ffffff);
					border: 1px solid var(--color-border-default, #d0d7de);
					border-radius: 12px;
					box-shadow: 0 16px 32px rgba(0,0,0,0.24);
					z-index: 10001;
					overflow: hidden;
					font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
				}

				.ghcm-search-header {
					padding: 16px 20px;
					background: var(--color-canvas-subtle, #f6f8fa);
					border-bottom: 1px solid var(--color-border-default, #d0d7de);
					display: flex;
					justify-content: space-between;
					align-items: center;
				}

				.ghcm-search-header h3 {
					margin: 0;
					font-size: 16px;
					font-weight: 600;
					color: var(--color-fg-default, #24292f);
				}

				.ghcm-search-close {
					background: none;
					border: none;
					font-size: 18px;
					cursor: pointer;
					padding: 6px;
					border-radius: 6px;
					color: var(--color-fg-muted, #656d76);
				}

				.ghcm-search-close:hover {
					background: var(--color-danger-subtle, #ffebe9);
					color: var(--color-danger-fg, #cf222e);
				}

				.ghcm-search-content {
					padding: 20px;
				}

				.ghcm-search-input {
					width: 100%;
					padding: 12px 16px;
					border: 2px solid var(--color-border-default, #d0d7de);
					border-radius: 8px;
					font-size: 16px;
					background: var(--color-canvas-default, #ffffff);
					color: var(--color-fg-default, #24292f);
					outline: none;
					transition: border-color 0.2s;
				}

				.ghcm-search-input:focus {
					border-color: var(--color-accent-emphasis, #0969da);
				}

				.ghcm-search-results {
					margin-top: 16px;
					max-height: 400px;
					overflow-y: auto;
				}

				/* ÊêúÁ¥¢ËøáÊª§Ê†è */
				.ghcm-search-filters {
					margin-top: 10px;
					display: flex;
					justify-content: space-between;
					align-items: center;
					flex-wrap: wrap;
					gap: 8px;
				}
				.ghcm-level-filters label {
					margin-right: 8px;
					font-size: 12px;
					color: var(--color-fg-muted, #656d76);
				}
				.ghcm-search-hint-row {
					font-size: 12px;
					color: var(--color-fg-muted, #656d76);
				}

				.ghcm-search-result {
					display: flex;
					align-items: center;
					padding: 12px 16px;
					border-radius: 8px;
					cursor: pointer;
					margin: 4px 0;
					border: 1px solid transparent;
				}

				.ghcm-search-result:hover {
					background: var(--color-neutral-subtle, #f6f8fa);
					border-color: var(--color-border-default, #d0d7de);
				}

				/* ÈîÆÁõòÂØºËà™È´ò‰∫Æ */
				.ghcm-search-result.active {
					background: var(--color-neutral-subtle, #f6f8fa);
					border-color: var(--color-border-default, #d0d7de);
				}

				.ghcm-search-level {
					background: var(--color-accent-subtle, #ddf4ff);
					color: var(--color-accent-fg, #0969da);
					padding: 2px 6px;
					border-radius: 4px;
					font-size: 11px;
					font-weight: 600;
					margin-right: 12px;
					min-width: 24px;
					text-align: center;
				}

				.ghcm-search-text {
					flex: 1;
					font-size: 14px;
					color: var(--color-fg-default, #24292f);
				}

				.ghcm-search-text mark {
					background: var(--color-attention-subtle, #fff8c5);
					color: var(--color-attention-fg, #9a6700);
					padding: 1px 2px;
					border-radius: 2px;
				}

				.ghcm-search-hint, .ghcm-search-no-results {
					text-align: center;
					padding: 40px 20px;
					color: var(--color-fg-muted, #656d76);
					font-style: italic;
				}

				/* Â∏ÆÂä©ÂºπÁ™ó */
				.ghcm-help-overlay {
					position: fixed;
					inset: 0;
					background: rgba(17, 24, 39, 0.45);
					backdrop-filter: blur(4px);
					display: flex;
					align-items: center;
					justify-content: center;
					padding: 24px;
					opacity: 0;
					transition: opacity 180ms ease;
					z-index: 10001;
				}

				.ghcm-help-overlay.show {
					opacity: 1;
				}

				.ghcm-help-modal {
					position: relative;
					width: min(720px, 90vw);
					max-height: min(90vh, 720px);
					background: var(--color-canvas-default, #ffffff);
					border-radius: 16px;
					border: 1px solid var(--color-border-default, #d0d7de);
					box-shadow: 0 24px 48px rgba(15, 23, 42, 0.26);
					display: flex;
					flex-direction: column;
					overflow: hidden;
					transform: translateY(10px) scale(0.96);
					transition: transform 200ms ease, opacity 200ms ease;
					opacity: 0;
				}

				.ghcm-help-modal:focus,
				.ghcm-help-modal:focus-visible {
					outline: none;
					box-shadow: 0 24px 48px rgba(15, 23, 42, 0.26), 0 0 0 3px rgba(99, 102, 241, 0.22);
				}

				.ghcm-help-overlay.show .ghcm-help-modal {
					transform: translateY(0) scale(1);
					opacity: 1;
				}

				.ghcm-help-header {
					display: flex;
					align-items: center;
					justify-content: space-between;
					padding: 20px 24px 16px;
					background: var(--color-canvas-subtle, #f6f8fa);
					border-bottom: 1px solid var(--color-border-default, #d0d7de);
					gap: 12px;
				}

				.ghcm-help-title {
					display: flex;
					flex-direction: column;
					gap: 4px;
				}

				.ghcm-help-title-text {
					font-size: 1.15rem;
					font-weight: 600;
					color: var(--color-fg-default, #1f2329);
				}

				.ghcm-help-title-sub {
					font-size: 0.85rem;
					color: var(--color-fg-muted, #4c566a);
				}

				.ghcm-help-close {
					width: 36px;
					height: 36px;
					border: none;
					border-radius: 50%;
					background: transparent;
					color: var(--color-fg-muted, #4c566a);
					cursor: pointer;
					transition: background 160ms ease, color 160ms ease, transform 160ms ease;
					font-size: 18px;
					line-height: 1;
				}

				.ghcm-help-close:hover {
					background: rgba(99, 102, 241, 0.08);
					color: var(--color-fg-default, #1f2329);
					transform: scale(1.05);
				}

				.ghcm-help-close:focus {
					outline: 2px solid rgba(99, 102, 241, 0.35);
					outline-offset: 2px;
				}

				.ghcm-help-content {
					padding: 20px 24px 28px;
					overflow: auto;
					scrollbar-width: thin;
				}

				.ghcm-help-content::-webkit-scrollbar {
					width: 8px;
				}

				.ghcm-help-content::-webkit-scrollbar-thumb {
					background: rgba(148, 163, 184, 0.5);
					border-radius: 999px;
				}

				.ghcm-help-content > .markdown-body {
					font-size: 14px;
					line-height: 1.65;
					color: var(--color-fg-default, #1f2329);
				}

				.ghcm-help-grid {
					display: grid;
					grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
					gap: 16px;
				}

				.ghcm-help-card {
					padding: 16px;
					border-radius: 12px;
					border: 1px solid rgba(99, 102, 241, 0.15);
					background: rgba(99, 102, 241, 0.05);
				}

				.ghcm-help-card h3 {
					margin-top: 0;
					margin-bottom: 8px;
					font-size: 0.95rem;
				}

				.ghcm-help-shortcut {
					display: flex;
					align-items: center;
					justify-content: space-between;
					gap: 12px;
					padding: 8px 0;
					border-bottom: 1px solid rgba(148, 163, 184, 0.2);
				}

				.ghcm-help-shortcut:last-child {
					border-bottom: none;
				}

				.ghcm-help-kbd {
					display: inline-flex;
					align-items: center;
					justify-content: center;
					min-width: 82px;
					padding: 6px 10px;
					border-radius: 8px;
					background: rgba(15, 23, 42, 0.05);
					border: 1px solid rgba(148, 163, 184, 0.4);
					font-family: ui-monospace, SFMono-Regular, SFMono, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
					font-size: 0.85rem;
					color: var(--color-fg-default, #1f2329);
				}

				.ghcm-help-kbd span {
					white-space: nowrap;
				}

				.ghcm-help-list {
					display: grid;
					gap: 10px;
					padding-left: 0;
					list-style: none;
				}

				.ghcm-help-list li {
					display: flex;
					gap: 8px;
				}

				.ghcm-help-list strong {
					color: rgba(79, 70, 229, 1);
				}

				.ghcm-help-section + .ghcm-help-section {
					margin-top: 24px;
				}

				.ghcm-help-footnote {
					margin-top: 12px;
					font-size: 0.85rem;
					color: var(--color-fg-muted, #4c566a);
				}

				/* Ê∑±Ëâ≤‰∏ªÈ¢òÈÄÇÈÖç */
				@media (prefers-color-scheme: dark) {
					.${CONFIG.classes.tocContainer},
					.${CONFIG.classes.searchContainer} {
						background: var(--color-canvas-default, #0d1117);
						border-color: var(--color-border-default, #30363d);
					}

					.ghcm-help-overlay {
						background: rgba(15, 23, 42, 0.6);
					}

					.ghcm-help-modal {
						background: var(--color-canvas-default, #0d1117);
						border-color: var(--color-border-default, #30363d);
						box-shadow: 0 24px 48px rgba(8, 13, 23, 0.6);
					}

					.ghcm-help-modal:focus,
					.ghcm-help-modal:focus-visible {
						box-shadow: 0 24px 48px rgba(8, 13, 23, 0.6), 0 0 0 3px rgba(129, 140, 248, 0.35);
					}

					.ghcm-help-header {
						background: var(--color-canvas-subtle, #161b22);
						border-color: var(--color-border-default, #30363d);
					}

					.ghcm-help-title-text {
						color: var(--color-fg-default, #e6edf3);
					}

					.ghcm-help-title-sub,
					.ghcm-help-footnote {
						color: var(--color-fg-muted, #8b949e);
					}

					.ghcm-help-close {
						color: var(--color-fg-muted, #8b949e);
					}

					.ghcm-help-close:hover {
						background: rgba(99, 102, 241, 0.18);
						color: var(--color-fg-default, #e6edf3);
					}

					.ghcm-help-content > .markdown-body {
						color: var(--color-fg-default, #e6edf3);
					}

					.ghcm-help-card {
						background: rgba(79, 70, 229, 0.12);
						border-color: rgba(129, 140, 248, 0.45);
					}

					.ghcm-help-kbd {
						background: rgba(148, 163, 184, 0.12);
						border-color: rgba(148, 163, 184, 0.35);
						color: var(--color-fg-default, #e6edf3);
					}
				}
			`);
		}

		generateHeaderSelectors() {
			const containers = CONFIG.selectors.markdownContainers;
			const headers = DOMUtils.getHeadingTagsLower();

			const baseSelectors = [];
			const afterSelectors = [];

			containers.forEach(container => {
				if (container) {
					headers.forEach(header => {
						baseSelectors.push(`${container} ${header}`);
						baseSelectors.push(`${container} ${header}.heading-element`);
						afterSelectors.push(`${container} ${header}:after`);
						afterSelectors.push(`${container} ${header}.heading-element:after`);
					});
				}
			});

			return {
				base: baseSelectors.join(", "),
				after: afterSelectors.join(", ")
			};
		}

		generateArrowContent() {
			const headers = DOMUtils.getHeadingTagsLower();
			return headers.map((header, index) => {
				const level = index + 1;
				const containers = CONFIG.selectors.markdownContainers;
				const selectors = [];

				containers.forEach(container => {
					if (container) {
						selectors.push(`${container} ${header}:after`);
						selectors.push(`${container} ${header}.heading-element:after`);
					}
				});

				return `${selectors.join(", ")} { content: "${level}‚ñº"; }`;
			}).join("\n");
		}

		addColorStyles() {
			const headers = DOMUtils.getHeadingTagsLower();
			const styles = headers.map((header, index) => {
				const containers = CONFIG.selectors.markdownContainers;
				const selectors = [];

				containers.forEach(container => {
					if (container) {
						selectors.push(`${container} ${header}:after`);
						selectors.push(`${container} ${header}.heading-element:after`);
					}
				});

				return `${selectors.join(", ")} { color: ${CONFIG.colors[index]}; }`;
			}).join("\n");

			this.arrowColors.textContent = styles;
		}

			updateColors(newColors) {
				CONFIG.colors = newColors;
				GM_setValue("ghcm-colors", newColors);
				this.addColorStyles();
		}

		applyArrowSize(size) {
			try {
				document.documentElement.style.setProperty('--ghcm-arrow-size', size || '0.8em');
			} catch {}
		}

		updateArrowSize(size) {
			if (!size) return;
			CONFIG.ui.arrowSize = size;
			GM_setValue('ghcm-arrow-size', size);
			this.applyArrowSize(size);
		}

		updateArrowContentOverride() {
			const headerSelectors = this.generateHeaderSelectors();
			const after = headerSelectors.after;
			const showNum = !!CONFIG.ui.showLevelNumber;
			if (!showNum) {
				// ‰ªÖÊòæÁ§∫ÁÆ≠Â§¥ÔºàË¶ÜÁõñÂàùÂßãÂ∏¶Êï∞Â≠óÁöÑÂÜÖÂÆπÔºâ
				this.arrowContentOverride.textContent = `${after} { content: "\\25BC" !important; }`;
			} else {
				// ÊòæÁ§∫Á∫ßÂà´Êï∞Â≠ó + ÁÆ≠Â§¥ÔºåË¶ÜÁõñ‰ª•Á°Æ‰øù‰∏éÂΩìÂâçËÆæÁΩÆ‰∏ÄËá¥
				const headers = DOMUtils.getHeadingTagsLower();
				const rules = headers.map((header, index) => {
					const level = index + 1;
					const containers = CONFIG.selectors.markdownContainers;
					const selectors = [];
					containers.forEach(container => {
						if (container) {
							selectors.push(`${container} ${header}:after`);
							selectors.push(`${container} ${header}.heading-element:after`);
						}
					});
					return `${selectors.join(", ")} { content: "${level}\\25BC" !important; }`;
				}).join("\n");
				this.arrowContentOverride.textContent = rules;
			}
		}
	}

	// ÊäòÂè†ÂäüËÉΩÊ†∏ÂøÉÁ±ª
class CollapseManager {
	constructor(stateManager) {
		this.stateManager = stateManager;
		// Map<headerKey, Set<timeoutId>> to track and cancel animations per header
		this.animationQueue = new Map();
		// Âçï‰∏ÄÊªöÂä®Ê†°ÂáÜÂÆöÊó∂Âô®ÔºåÈò≤Ê≠¢Âø´ÈÄüÁÇπÂáª‰∫ßÁîüÊù•ÂõûÊªöÂä®
		this._scrollEnsureTimeout = null;
		this.activeHeading = null;
		this._activeNotification = null;
	}

	// Track a timeout for a header key
	trackTimeout(headerKey, timeoutId) {
		if (!this.animationQueue.has(headerKey)) {
			this.animationQueue.set(headerKey, new Set());
		}
		this.animationQueue.get(headerKey).add(timeoutId);
	}

	// Cancel all pending timeouts for a header key
	cancelTimeouts(headerKey) {
		const set = this.animationQueue.get(headerKey);
		if (!set) return;
		set.forEach(id => clearTimeout(id));
		this.animationQueue.delete(headerKey);
	}

	// Cancel all pending animations (used on navigation)
	clearAllAnimations() {
		for (const set of this.animationQueue.values()) {
			set.forEach(id => clearTimeout(id));
		}
		this.animationQueue.clear();
	}

		toggle(header, isShiftClicked = false) {
			if (!header || header.classList.contains(CONFIG.classes.noContent)) {
				return;
			}

			const startTime = performance.now();
			const level = this.stateManager.getHeaderLevel(header);
			const isCollapsed = !header.classList.contains(CONFIG.classes.collapsed);

			Logger.log("[GHCM] Toggle:", header, "Level:", level, "Will collapse:", isCollapsed);

			if (isShiftClicked) {
				this.toggleAllSameLevel(level, isCollapsed);
			} else {
				this.toggleSingle(header, isCollapsed);
			}

			// ÊÄßËÉΩÁõëÊéß
			const endTime = performance.now();
			const duration = endTime - startTime;

			if (duration > 100 && CONFIG.animation.maxAnimatedElements > 0) {
				Logger.warn(`[GHCM] Ê£ÄÊµãÂà∞ÊÄßËÉΩÈóÆÈ¢ò (${duration.toFixed(1)}ms)ÔºåÂª∫ËÆÆÂêØÁî®ÊÄßËÉΩÊ®°Âºè`);

				// Ëá™Âä®ÈôçÁ∫ßÊÄßËÉΩËÆæÁΩÆ
				if (!GM_getValue("ghcm-auto-performance-warned", false)) {
					CONFIG.animation.maxAnimatedElements = Math.max(5, CONFIG.animation.maxAnimatedElements / 2);
					Logger.log(`[GHCM] Ëá™Âä®Ë∞ÉÊï¥Âä®ÁîªÈòàÂÄº‰∏∫: ${CONFIG.animation.maxAnimatedElements}`);
					GM_setValue("ghcm-auto-performance-warned", true);
				}
			}

			this.setActiveHeading(header);
			DOMUtils.clearSelection();
			DOMUtils.blurActiveElement();
			this.dispatchToggleEvent(header, level, isCollapsed);
		}

		toggleSingle(header, isCollapsed) {
			header.classList.toggle(CONFIG.classes.collapsed, isCollapsed);
			this.updateAriaExpanded(header);
			this.updateContent(header, isCollapsed);
		}

		toggleAllSameLevel(level, isCollapsed) {
			const selectors = CONFIG.selectors.markdownContainers
				.map(container => DOMUtils.getScopedHeadingSelector(container, {
					level,
					includeWrapper: true
				}))
				.filter(Boolean)
				.join(', ');

			if (!selectors) return;

			DOMUtils.$$(selectors).forEach(header => {
				if (DOMUtils.isHeader(header)) {
					header.classList.toggle(CONFIG.classes.collapsed, isCollapsed);
					this.updateAriaExpanded(header);
					this.updateContent(header, isCollapsed);
				}
			});
		}

		updateAriaExpanded(header) {
			try {
				const expanded = !header.classList.contains(CONFIG.classes.collapsed);
				header.setAttribute('aria-expanded', String(expanded));
			} catch {}
		}

		updateContent(header, isCollapsed) {
			const level = this.stateManager.getHeaderLevel(header);
			const headerKey = this.stateManager.generateHeaderKey(header);
			const elements = this.getContentElements(header, level);

			// ÂàÜÊûêÂÖÉÁ¥†ÔºöÂå∫ÂàÜÊôÆÈÄöÂÜÖÂÆπÂíåÂ≠êÊ†áÈ¢ò
			const analyzedElements = elements.map(el => {
				const childHeader = DOMUtils.isHeader(el) ? el : el.querySelector(DOMUtils.getUpperHeadingSelector());
				return {
					element: el,
					isHeader: !!childHeader,
					childHeader: childHeader,
					childHeaderCollapsed: childHeader ? childHeader.classList.contains(CONFIG.classes.collapsed) : false
				};
			});

		// Êõ¥Êñ∞Áä∂ÊÄÅÔºà‰ªÖÂ≠òÊäòÂè†Â∏ÉÂ∞îÔºåÈÅøÂÖç DOM ÂºïÁî®Â∏∏È©ªÔºâ
		this.stateManager.setHeaderState(headerKey, { isCollapsed });

			// ÊâßË°åÊô∫ËÉΩÂä®ÁîªÔºàËÄÉËôëÂ≠êÊ†áÈ¢òÁä∂ÊÄÅÔºâ
			this.animateElementsIntelligent(analyzedElements, isCollapsed, headerKey);
		}

		getContentElements(header, level) {
			const container = DOMUtils.getHeaderContainer(header);
			const elements = [];
			let nextElement = container.nextElementSibling;

			// ÊûÑÂª∫ÂêåÁ∫ßÂíåÊõ¥È´òÁ∫ßÂà´ÁöÑÈÄâÊã©Âô®
			const higherLevelSelectors = DOMUtils.getHeadingSelectorUpToLevel(level);

			while (nextElement) {
				// Â¶ÇÊûúÈÅáÂà∞ÂêåÁ∫ßÊàñÊõ¥È´òÁ∫ßÂà´ÁöÑÊ†áÈ¢òÔºåÂÅúÊ≠¢
				if (nextElement.matches(higherLevelSelectors) ||
					(nextElement.classList?.contains('markdown-heading') &&
					nextElement.querySelector(higherLevelSelectors))) {
				break;
			}

				elements.push(nextElement);
				nextElement = nextElement.nextElementSibling;
			}

			return elements;
		}

		animateElements(elements, isCollapsed, headerKey) {
		// ÂèñÊ∂à‰πãÂâçÁöÑÂä®Áîª
		this.cancelTimeouts(headerKey);

			// ÊÄßËÉΩ‰ºòÂåñÔºöÂ¶ÇÊûúÂÖÉÁ¥†Â§™Â§öÔºåÁõ¥Êé•ÂàáÊç¢ËÄå‰∏çÂÅöÂä®Áîª
			if (elements.length > CONFIG.animation.maxAnimatedElements) {
				this.toggleElementsInstantly(elements, isCollapsed);
				return;
			}

			// ÂØπ‰∫éÈÄÇÈáèÂÖÉÁ¥†Ôºå‰ΩøÁî®‰ºòÂåñÁöÑÊâπÈáèÂä®Áîª
			this.animateElementsBatch(elements, isCollapsed, headerKey);
		}

		// Êñ∞ÁöÑÊô∫ËÉΩÂä®ÁîªÊñπÊ≥ïÔºåËÄÉËôëÂ≠êÊ†áÈ¢òÁä∂ÊÄÅ
		animateElementsIntelligent(analyzedElements, isCollapsed, headerKey) {
		// ÂèñÊ∂à‰πãÂâçÁöÑÂä®Áîª
		this.cancelTimeouts(headerKey);

			Logger.log(`[GHCM] Êô∫ËÉΩÂä®Áîª: ${analyzedElements.length} ‰∏™ÂÖÉÁ¥†, ÈòàÂÄº: ${CONFIG.animation.maxAnimatedElements}`);

			// ÊÄßËÉΩ‰ºòÂåñÔºöÂ¶ÇÊûúÂÖÉÁ¥†Â§™Â§öÔºåÁõ¥Êé•ÂàáÊç¢
			if (analyzedElements.length > CONFIG.animation.maxAnimatedElements) {
				Logger.log(`[GHCM] ÂÖÉÁ¥†ËøáÂ§öÔºå‰ΩøÁî®Âç≥Êó∂ÂàáÊç¢Ê®°Âºè`);
				this.toggleElementsIntelligentInstantly(analyzedElements, isCollapsed);
				return;
			}

			// ‰ΩøÁî®Êô∫ËÉΩÊâπÈáèÂä®Áîª
			Logger.log(`[GHCM] ‰ΩøÁî®ÊâπÈáèÂä®ÁîªÊ®°Âºè`);
			this.animateElementsIntelligentBatch(analyzedElements, isCollapsed, headerKey);
		}

		// Êô∫ËÉΩÂç≥Êó∂ÂàáÊç¢ÔºàÊÄßËÉΩÊ®°ÂºèÔºâ
		toggleElementsIntelligentInstantly(analyzedElements, isCollapsed) {
			Logger.log(`[GHCM] ÊÄßËÉΩÊ®°ÂºèÔºöÂç≥Êó∂ÂàáÊç¢ ${analyzedElements.length} ‰∏™ÂÖÉÁ¥†`);

			analyzedElements.forEach(({ element, isHeader, childHeader, childHeaderCollapsed }) => {
				if (isCollapsed) {
					// ÊäòÂè†ÔºöÈöêËóèÊâÄÊúâÂÜÖÂÆπ
					element.classList.add(CONFIG.classes.hiddenByParent);
					element.style.removeProperty('display');
				} else {
					// Â±ïÂºÄÔºöÊ†πÊçÆÂ≠êÊ†áÈ¢òÁä∂ÊÄÅÂÜ≥ÂÆöÊòØÂê¶ÊòæÁ§∫
					element.classList.remove(CONFIG.classes.hiddenByParent);
					element.style.removeProperty('display');

					// Â¶ÇÊûúÊòØÂ≠êÊ†áÈ¢ò‰∏îÂéüÊú¨ÊòØÊäòÂè†ÁöÑÔºåÈúÄË¶Å‰øùÊåÅÂÖ∂ÂÜÖÂÆπÈöêËóè
					if (isHeader && childHeaderCollapsed) {
						setTimeout(() => {
							this.ensureChildHeaderContentHidden(childHeader);
						}, 10);
					}

					// Ê∏ÖÁêÜÂä®ÁîªÊ†∑Âºè
					element.style.removeProperty('opacity');
					element.style.removeProperty('transform');
					element.style.removeProperty('transition');
					element.classList.remove('ghcm-transitioning');
				}
			});
		}

				// Êô∫ËÉΩÊâπÈáèÂä®Áîª
		animateElementsIntelligentBatch(analyzedElements, isCollapsed, headerKey) {
			// Ê£ÄÊü•ÊòØÂê¶Â∫îËØ•‰ΩøÁî®Âä®Áîª
			if (CONFIG.animation.maxAnimatedElements === 0) {
				this.toggleElementsIntelligentInstantly(analyzedElements, isCollapsed);
				return;
			}

			const batches = this.createIntelligentBatches(analyzedElements, CONFIG.animation.batchSize);

			const processBatch = (batchIndex) => {
				if (batchIndex >= batches.length) return;

				const batch = batches[batchIndex];

			if (isCollapsed) {
				this.collapseIntelligentBatch(batch, headerKey);
			} else {
				this.expandIntelligentBatch(batch, headerKey);
			}

				// Â§ÑÁêÜ‰∏ã‰∏Ä‰∏™ÊâπÊ¨°
			if (batchIndex < batches.length - 1) {
				const timeout = setTimeout(() => {
					processBatch(batchIndex + 1);
				}, 30); // ÂáèÂ∞ëÂª∂ËøüÔºåËÆ©Âä®ÁîªÊõ¥ÊµÅÁïÖ
				this.trackTimeout(headerKey, timeout);
			}
		};

			processBatch(0);
		}

		createIntelligentBatches(analyzedElements, batchSize) {
			const batches = [];
			for (let i = 0; i < analyzedElements.length; i += batchSize) {
				batches.push(analyzedElements.slice(i, i + batchSize));
			}
			return batches;
		}

	collapseIntelligentBatch(batch, headerKey) {
			Logger.log(`[GHCM] ÊäòÂè†Âä®ÁîªÊâπÊ¨°: ${batch.length} ‰∏™ÂÖÉÁ¥†`);

			// ÊäòÂè†ÊâπÊ¨°ÔºöÂÖàËÆæÁΩÆÂàùÂßãÁä∂ÊÄÅÂíåËøáÊ∏°ÊïàÊûú
			batch.forEach(({ element }) => {
				element.style.opacity = '1';
				element.style.transform = 'translateY(0)';
				element.style.transition = `opacity ${CONFIG.animation.duration}ms ${CONFIG.animation.easing}, transform ${CONFIG.animation.duration}ms ${CONFIG.animation.easing}`;
			});

			// ‰ΩøÁî®requestAnimationFrameÁ°Æ‰øùÊ†∑ÂºèÂ∑≤Â∫îÁî®
			requestAnimationFrame(() => {
				batch.forEach(({ element }) => {
					element.style.opacity = '0';
					element.style.transform = 'translateY(-8px)';
				});

				// Âä®ÁîªÂÆåÊàêÂêéÈöêËóèÂÖÉÁ¥†
								const t = setTimeout(() => {
					batch.forEach(({ element }) => {
						element.classList.add(CONFIG.classes.hiddenByParent);
						element.style.removeProperty('display');
						element.style.removeProperty('opacity');
						element.style.removeProperty('transform');
						element.style.removeProperty('transition');
					});
					Logger.log(`[GHCM] ÊäòÂè†Âä®ÁîªÊâπÊ¨°ÂÆåÊàê`);
				}, CONFIG.animation.duration);
				this.trackTimeout(headerKey, t);
			});
		}

	expandIntelligentBatch(batch, headerKey) {
			Logger.log(`[GHCM] Â±ïÂºÄÂä®ÁîªÊâπÊ¨°: ${batch.length} ‰∏™ÂÖÉÁ¥†`);

			// Â±ïÂºÄÊâπÊ¨°ÔºöÂÖàÊòæÁ§∫ÂÖÉÁ¥†‰ΩÜËÆæ‰∏∫ÂàùÂßãÂä®ÁîªÁä∂ÊÄÅ
			batch.forEach(({ element, isHeader, childHeader, childHeaderCollapsed }) => {
				element.classList.remove(CONFIG.classes.hiddenByParent);
				element.style.removeProperty('display');
				element.style.opacity = '0';
				element.style.transform = 'translateY(-8px)';
				element.style.transition = `opacity ${CONFIG.animation.duration}ms ${CONFIG.animation.easing}, transform ${CONFIG.animation.duration}ms ${CONFIG.animation.easing}`;
			});

			// ‰ΩøÁî®requestAnimationFrameÁ°Æ‰øùDOMÊõ¥Êñ∞ÂÆåÊàê
			requestAnimationFrame(() => {
				batch.forEach(({ element, isHeader, childHeader, childHeaderCollapsed }) => {
					element.style.opacity = '1';
					element.style.transform = 'translateY(0)';

					// Â¶ÇÊûúÊòØÂ≠êÊ†áÈ¢ò‰∏îÂéüÊú¨ÊòØÊäòÂè†ÁöÑÔºåÁ°Æ‰øùÂÖ∂ÂÜÖÂÆπ‰øùÊåÅÈöêËóè
					if (isHeader && childHeaderCollapsed) {
						// Âª∂ËøüÊâßË°åÔºåÁ°Æ‰øùÂä®ÁîªÂíåDOMÊõ¥Êñ∞ÂÆåÊàê
                        setTimeout(() => {
							this.ensureChildHeaderContentHidden(childHeader);
						}, CONFIG.animation.duration + 50);
					}
				});

				// Ê∏ÖÁêÜÊ†∑Âºè
				const t = setTimeout(() => {
					batch.forEach(({ element }) => {
						element.style.removeProperty('opacity');
						element.style.removeProperty('transform');
						element.style.removeProperty('transition');
					});
					Logger.log(`[GHCM] Â±ïÂºÄÂä®ÁîªÊâπÊ¨°ÂÆåÊàê`);
				}, CONFIG.animation.duration);
				this.trackTimeout(headerKey, t);
			});
		}

		// Á°Æ‰øùÂ≠êÊ†áÈ¢òÁöÑÂÜÖÂÆπ‰øùÊåÅÈöêËóèÁä∂ÊÄÅ
		ensureChildHeaderContentHidden(childHeader) {
			if (!childHeader || !childHeader.classList.contains(CONFIG.classes.collapsed)) {
				return;
			}

			const childLevel = this.stateManager.getHeaderLevel(childHeader);
			const childElements = this.getContentElements(childHeader, childLevel);

			// Á´ãÂç≥ÈöêËóèÂ≠êÊ†áÈ¢òÁöÑÂÜÖÂÆπÔºå‰∏ç‰ΩøÁî®Âä®Áîª
			childElements.forEach(element => {
				element.classList.add(CONFIG.classes.hiddenByParent);
				element.style.removeProperty('display');
				element.style.removeProperty('opacity');
				element.style.removeProperty('transform');
				element.classList.remove('ghcm-transitioning');
			});

			Logger.log(`[GHCM] Â∑≤ÊÅ¢Â§çÂ≠êÊ†áÈ¢òÁöÑÊäòÂè†Áä∂ÊÄÅ:`, childHeader.textContent.trim());
		}

		// Âç≥Êó∂ÂàáÊç¢ÔºåÊó†Âä®Áîª
		toggleElementsInstantly(elements, isCollapsed) {
			// ÊâπÈáèDOMÊìç‰ΩúÔºåÂáèÂ∞ëÈáçÊéí

			elements.forEach(element => {
				if (isCollapsed) {
					element.classList.add(CONFIG.classes.hiddenByParent);
					element.style.removeProperty('display');
            } else {
					element.classList.remove(CONFIG.classes.hiddenByParent);
					element.style.removeProperty('display');
					// Ê∏ÖÁêÜÂèØËÉΩÂ≠òÂú®ÁöÑÂä®ÁîªÊ†∑Âºè
					element.style.removeProperty('opacity');
					element.style.removeProperty('transform');
					element.classList.remove('ghcm-transitioning');
				}
			});
		}

		// ÊâπÈáèÂä®ÁîªÂ§ÑÁêÜ
		animateElementsBatch(elements, isCollapsed, headerKey) {
			const batches = this.createBatches(elements, CONFIG.animation.batchSize);
			let completedBatches = 0;

			const processBatch = (batchIndex) => {
				if (batchIndex >= batches.length) return;

				const batch = batches[batchIndex];

				// ‰∏∫ÊØè‰∏™ÊâπÊ¨°ÂáÜÂ§áDOMÂèòÊõ¥
			if (isCollapsed) {
				this.collapseBatch(batch, headerKey);
			} else {
				this.expandBatch(batch, headerKey);
			}

				completedBatches++;

				// Â§ÑÁêÜ‰∏ã‰∏Ä‰∏™ÊâπÊ¨°
				if (batchIndex < batches.length - 1) {
					const timeout = setTimeout(() => {
						processBatch(batchIndex + 1);
					}, 50); // ÊâπÊ¨°Èó¥Áü≠ÊöÇÂª∂Ëøü
					this.trackTimeout(headerKey, timeout);
				}
		};

			processBatch(0);
		}

		createBatches(elements, batchSize) {
			const batches = [];
			for (let i = 0; i < elements.length; i += batchSize) {
				batches.push(elements.slice(i, i + batchSize));
			}
			return batches;
		}

	collapseBatch(batch, headerKey) {
			// ÂÖàËÆæÁΩÆÂàùÂßãÁä∂ÊÄÅ
			batch.forEach(element => {
				element.style.transition = `opacity ${CONFIG.animation.duration}ms ${CONFIG.animation.easing}`;
				element.style.opacity = '1';
			});

			// Ëß¶ÂèëÂä®Áîª
			requestAnimationFrame(() => {
				batch.forEach(element => {
					element.style.opacity = '0';
				});

				// Âä®ÁîªÂÆåÊàêÂêéÈöêËóè
					const t = setTimeout(() => {
					batch.forEach(element => {
						element.classList.add(CONFIG.classes.hiddenByParent);
						element.style.removeProperty('display');
						element.style.removeProperty('opacity');
						element.style.removeProperty('transition');
					});
				}, CONFIG.animation.duration);
				this.trackTimeout(headerKey, t);
			});
		}

	expandBatch(batch, headerKey) {
			// ÂÖàÊòæÁ§∫ÂÖÉÁ¥†‰ΩÜËÆæ‰∏∫ÈÄèÊòé
			batch.forEach(element => {
				element.classList.remove(CONFIG.classes.hiddenByParent);
				element.style.removeProperty('display');
				element.style.opacity = '0';
				element.style.transition = `opacity ${CONFIG.animation.duration}ms ${CONFIG.animation.easing}`;
			});

			// Ëß¶ÂèëÊ∑°ÂÖ•Âä®Áîª
			requestAnimationFrame(() => {
				batch.forEach(element => {
					element.style.opacity = '1';
				});

				// Ê∏ÖÁêÜÊ†∑Âºè
						const t = setTimeout(() => {
					batch.forEach(element => {
						element.style.removeProperty('opacity');
						element.style.removeProperty('transition');
					});
					}, CONFIG.animation.duration);
					this.trackTimeout(headerKey, t);
			});
		}

		// Â±ïÂºÄÂà∞ÊåáÂÆöÊ†áÈ¢òÔºàÁî®‰∫éhashÂØºËà™Ôºâ
		expandToHeader(targetHeader, { scroll = true, setActive = true } = {}) {
			if (!targetHeader) return;

			const level = this.stateManager.getHeaderLevel(targetHeader);
			let current = targetHeader;

			// Âêë‰∏äÊü•ÊâæÊâÄÊúâÁà∂Á∫ßÊ†áÈ¢òÂπ∂Â±ïÂºÄ
			while (current) {
				const container = DOMUtils.getHeaderContainer(current);
				let previous = container.previousElementSibling;
				let foundParent = false;

				// Êü•ÊâæÊõ¥È´òÁ∫ßÂà´ÁöÑÁà∂Ê†áÈ¢ò
				while (previous) {
					const parentHeader = this.findHeaderInElement(previous, level - 1);
					if (parentHeader) {
						if (parentHeader.classList.contains(CONFIG.classes.collapsed)) {
							this.toggleSingle(parentHeader, false);
						}
						current = parentHeader;
						foundParent = true;
						break;
					}
					previous = previous.previousElementSibling;
				}

				if (!foundParent) break;
			}

			// ÊªöÂä®Âà∞ÁõÆÊ†á‰ΩçÁΩÆ
			if (scroll) {
				this.scrollToElement(targetHeader);
			}
			if (setActive) {
				this.setActiveHeading(targetHeader, { scroll: false });
			}
		}

		findHeaderInElement(element, maxLevel) {
			if (DOMUtils.isHeader(element)) {
				const elementLevel = this.stateManager.getHeaderLevel(element);
				if (elementLevel <= maxLevel) return element;
			}

			// Êü•ÊâæÂÆπÂô®ÂÜÖÁöÑÊ†áÈ¢ò
			for (let i = 1; i < maxLevel; i++) {
				const headerName = CONFIG.selectors.headers[i - 1].toLowerCase();
				const header = element.querySelector(headerName) ||
							  element.querySelector(`${headerName}.heading-element`);
				if (header) return header;
			}

			return null;
		}

		scrollToElement(element) {
			if (!element) return;

			// È°∂ÈÉ®ÂÅèÁßªËÄÉËôë GitHub È°∂Ê†èÈ´òÂ∫¶
			const headerEl = document.querySelector('header[role="banner"], .Header, .AppHeader-globalBar');
			const headerOffset = (headerEl?.offsetHeight || 80) + 20; // È¢ùÂ§ñÁïôÁôΩ
			const rect = element.getBoundingClientRect();
			const targetPosition = Math.max(0, rect.top + window.pageYOffset - headerOffset);

			// Âπ≥ÊªëÊªöÂä®
			window.scrollTo({ top: targetPosition, behavior: 'smooth' });

			// Âª∂ËøüÂÜçÊ¨°Á°Æ‰øù‰ΩçÁΩÆÊ≠£Á°Æ
			if (this._scrollEnsureTimeout) clearTimeout(this._scrollEnsureTimeout);
			this._scrollEnsureTimeout = setTimeout(() => {
				if (Math.abs(window.scrollY - targetPosition) > 50) {
					window.scrollTo({ top: targetPosition, behavior: 'smooth' });
				}
			}, 500);
		}

		setActiveHeading(element, { scroll = false } = {}) {
			if (!element) return;
			let header = element;
			if (!DOMUtils.isHeader(header)) {
				header = header.querySelector(DOMUtils.getUpperHeadingSelector());
			}
			if (!header) return;
			if (this.activeHeading && this.activeHeading !== header) {
				try { this.activeHeading.classList.remove(CONFIG.classes.activeHeading); } catch {}
			}
			this.activeHeading = header;
			try { header.classList.add(CONFIG.classes.activeHeading); } catch {}
			try {
				const id = this.tocGenerator?.getHeaderId?.(header) || header.id || header.getAttribute('id');
				if (id && this.tocGenerator?.tocContainer) {
					this.tocGenerator.highlightTocById(id);
				}
			} catch {}
			if (scroll) {
				this.scrollToElement(header);
			}
		}

		getActiveHeaderElement(force = false) {
			if (!force && this.activeHeading && document.contains(this.activeHeading)) {
				return this.activeHeading;
			}
			const headers = this.getAllHeaders();
			if (!headers.length) return null;
			const headerEl = document.querySelector('header[role="banner"], .Header, .AppHeader-globalBar');
			const headerOffset = (headerEl?.offsetHeight || 80) + 20;
			const position = window.scrollY + headerOffset + 1;
			let active = headers[0];
			for (const header of headers) {
				const top = header.getBoundingClientRect().top + window.pageYOffset;
				if (top <= position) {
					active = header;
				} else {
					break;
				}
			}
			if (active) {
				this.setActiveHeading(active);
			}
			return active;
		}

		isHeaderNavigable(header) {
			if (!header) return false;
			if (header.classList?.contains(CONFIG.classes.hidden) ||
				header.classList?.contains(CONFIG.classes.hiddenByParent)) {
				return false;
			}
			try {
				if (header.closest(`.${CONFIG.classes.hiddenByParent}`)) {
					return false;
				}
			} catch {}
			try {
				const style = window.getComputedStyle(header);
				if (style.display === 'none' || style.visibility === 'hidden') {
					return false;
				}
			} catch {}
			return true;
		}

		findNavigableIndex(headers, startIndex, step) {
			for (let i = startIndex; i >= 0 && i < headers.length; i += step) {
				const candidate = headers[i];
				if (this.isHeaderNavigable(candidate)) {
					return i;
				}
			}
			return -1;
		}

		focusNextHeading() {
			DOMUtils.blurActiveElement();
			const headers = this.getAllHeaders();
			if (!headers.length) return;
			const current = this.getActiveHeaderElement();
			const currentIndex = headers.indexOf(current);
			const startIndex = currentIndex === -1 ? 0 : currentIndex + 1;
			const targetIndex = this.findNavigableIndex(headers, startIndex, 1);
			if (targetIndex === -1) {
				this.showNotification('üìå Â∑≤ÊòØÊúÄÂêé‰∏Ä‰∏™ÂèØËßÅÊ†áÈ¢ò');
				return;
			}
			const target = headers[targetIndex];
			this.expandToHeader(target, { scroll: false, setActive: false });
			this.scrollToElement(target);
			this.setActiveHeading(target);
		}

		focusPreviousHeading() {
			DOMUtils.blurActiveElement();
			const headers = this.getAllHeaders();
			if (!headers.length) return;
			const current = this.getActiveHeaderElement();
			const currentIndex = headers.indexOf(current);
			const startIndex = currentIndex === -1 ? headers.length - 1 : currentIndex - 1;
			const targetIndex = this.findNavigableIndex(headers, startIndex, -1);
			if (targetIndex === -1) {
				this.showNotification('üìå Â∑≤ÊòØÁ¨¨‰∏Ä‰∏™ÂèØËßÅÊ†áÈ¢ò');
				return;
			}
			const target = headers[targetIndex];
			this.expandToHeader(target, { scroll: false, setActive: false });
			this.scrollToElement(target);
			this.setActiveHeading(target);
		}

		dispatchToggleEvent(header, level, isCollapsed) {
			document.dispatchEvent(new CustomEvent("ghcm:toggle-complete", {
				detail: { header, level, isCollapsed }
			}));

			// Â¶ÇÊûúÊòØÂ±ïÂºÄÊìç‰ΩúÔºåÊ£ÄÊü•Âπ∂ÊÅ¢Â§çÂ≠êÊ†áÈ¢òÁä∂ÊÄÅ
			if (!isCollapsed) {
				setTimeout(() => {
					this.checkAndRestoreChildHeaderStates(header, level);
				}, CONFIG.animation.duration + 100);
			}
		}

		// Ê£ÄÊü•Âπ∂ÊÅ¢Â§çÂ≠êÊ†áÈ¢òÁöÑÊäòÂè†Áä∂ÊÄÅ
		checkAndRestoreChildHeaderStates(parentHeader, parentLevel) {
			const container = DOMUtils.getHeaderContainer(parentHeader);
			let nextElement = container.nextElementSibling;

			// Êü•ÊâæÊâÄÊúâÂ≠êÊ†áÈ¢òÂπ∂ÊÅ¢Â§çÂÖ∂Áä∂ÊÄÅ
			const higherLevelSelectors = DOMUtils.getHeadingSelectorUpToLevel(parentLevel);
			while (nextElement) {
				// ÂÅúÊ≠¢Êù°‰ª∂ÔºöÈÅáÂà∞ÂêåÁ∫ßÊàñÊõ¥È´òÁ∫ßÂà´ÁöÑÊ†áÈ¢ò
				if (nextElement.matches(higherLevelSelectors) ||
					(nextElement.classList?.contains('markdown-heading') &&
					nextElement.querySelector(higherLevelSelectors))) {
					break;
				}

				// Ê£ÄÊü•ÊòØÂê¶ÊòØÂ≠êÊ†áÈ¢ò
				const childHeader = DOMUtils.isHeader(nextElement) ?
					nextElement : nextElement.querySelector(DOMUtils.getUpperHeadingSelector());

				if (childHeader && childHeader.classList.contains(CONFIG.classes.collapsed)) {
					// Á°Æ‰øùËøô‰∏™Â≠êÊ†áÈ¢òÁöÑÂÜÖÂÆπ‰øùÊåÅÈöêËóè
					this.ensureChildHeaderContentHidden(childHeader);
				}

				nextElement = nextElement.nextElementSibling;
			}
		}

		// ÊâπÈáèÊìç‰ΩúÊñπÊ≥ï
		getAllHeaders() {
			return DOMUtils.collectHeadings();
		}

		syncAriaExpandedForAll() {
			try {
				this.getAllHeaders().forEach(h => {
					const expanded = !h.classList.contains(CONFIG.classes.collapsed);
					h.setAttribute('aria-expanded', String(expanded));
				});
			} catch {}
		}

		collapseAll() {
			const headers = this.getAllHeaders();
			let count = 0;

			headers.forEach(header => {
				if (!header.classList.contains(CONFIG.classes.collapsed) &&
					!header.classList.contains(CONFIG.classes.noContent)) {
					header.classList.add(CONFIG.classes.collapsed);
					this.updateAriaExpanded(header);
					this.updateContent(header, true);
					count++;
				}
			});

			Logger.log(`[GHCM] Â∑≤ÊäòÂè† ${count} ‰∏™Ê†áÈ¢ò`);
			this.showNotification(`üìÅ Â∑≤ÊäòÂè† ${count} ‰∏™Ê†áÈ¢ò`);
		}

		expandAll() {
			const headers = this.getAllHeaders();
			let count = 0;

			headers.forEach(header => {
				if (header.classList.contains(CONFIG.classes.collapsed)) {
					header.classList.remove(CONFIG.classes.collapsed);
					this.updateAriaExpanded(header);
					this.updateContent(header, false);
					count++;
				}
			});

			Logger.log(`[GHCM] Â∑≤Â±ïÂºÄ ${count} ‰∏™Ê†áÈ¢ò`);
			this.showNotification(`üìÇ Â∑≤Â±ïÂºÄ ${count} ‰∏™Ê†áÈ¢ò`);
		}

		toggleAll() {
			const headers = this.getAllHeaders();
			const collapsedCount = headers.filter(h =>
				h.classList.contains(CONFIG.classes.collapsed)
			).length;
			const totalCount = headers.filter(h =>
				!h.classList.contains(CONFIG.classes.noContent)
			).length;

			// Â¶ÇÊûúË∂ÖËøá‰∏ÄÂçäÂ∑≤ÊäòÂè†ÔºåÂàôÂÖ®ÈÉ®Â±ïÂºÄÔºõÂê¶ÂàôÂÖ®ÈÉ®ÊäòÂè†
			if (collapsedCount > totalCount / 2) {
				this.expandAll();
			} else {
				this.collapseAll();
			}
		}

		// ÊåâÁ∫ßÂà´ÊâπÈáèÊìç‰Ωú
		collapseLevel(level) {
			const selectors = CONFIG.selectors.markdownContainers
				.map(container => DOMUtils.getScopedHeadingSelector(container, { level }))
				.filter(Boolean)
				.join(', ');
			if (!selectors) return;

			const headers = DOMUtils.$$(selectors).filter(el => DOMUtils.isHeader(el));

			let count = 0;
			headers.forEach(header => {
				if (!header.classList.contains(CONFIG.classes.collapsed) &&
					!header.classList.contains(CONFIG.classes.noContent)) {
					header.classList.add(CONFIG.classes.collapsed);
					this.updateAriaExpanded(header);
					this.updateContent(header, true);
					count++;
				}
			});

			Logger.log(`[GHCM] Â∑≤ÊäòÂè† ${count} ‰∏™ H${level} Ê†áÈ¢ò`);
			this.showNotification(`üìÅ Â∑≤ÊäòÂè† ${count} ‰∏™ H${level} Ê†áÈ¢ò`);
		}

		expandLevel(level) {
			const selectors = CONFIG.selectors.markdownContainers
				.map(container => DOMUtils.getScopedHeadingSelector(container, { level }))
				.filter(Boolean)
				.join(', ');
			if (!selectors) return;

			const headers = DOMUtils.$$(selectors).filter(el => DOMUtils.isHeader(el));

			let count = 0;
			headers.forEach(header => {
				if (header.classList.contains(CONFIG.classes.collapsed)) {
					header.classList.remove(CONFIG.classes.collapsed);
					this.updateAriaExpanded(header);
					this.updateContent(header, false);
					count++;
				}
			});

			Logger.log(`[GHCM] Â∑≤Â±ïÂºÄ ${count} ‰∏™ H${level} Ê†áÈ¢ò`);
			this.showNotification(`üìÇ Â∑≤Â±ïÂºÄ ${count} ‰∏™ H${level} Ê†áÈ¢ò`);
		}

		// ÈÄöÁü•ÂäüËÉΩ
		showNotification(message) {
			if (this._activeNotification) {
				try { this._activeNotification.remove(); } catch {}
				this._activeNotification = null;
			}

			// ÂàõÂª∫ÈÄöÁü•ÂÖÉÁ¥†
			const notification = document.createElement('div');
			notification.style.cssText = `
				position: fixed;
				top: 20px;
				left: 50%;
				transform: translateX(-50%);
				background: var(--color-canvas-default, #ffffff);
				border: 1px solid var(--color-border-default, #d0d7de);
				border-radius: 8px;
				padding: 12px 20px;
				box-shadow: 0 4px 12px rgba(0,0,0,0.15);
				z-index: 10002;
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
				font-size: 14px;
				color: var(--color-fg-default, #24292f);
				opacity: 0;
				transition: opacity 0.3s ease;
			`;
			notification.textContent = message;

			document.body.appendChild(notification);
			this._activeNotification = notification;

			// ÊòæÁ§∫Âä®Áîª
			requestAnimationFrame(() => {
				notification.style.opacity = '1';
			});

			// Ëá™Âä®Ê∂àÂ§±
			setTimeout(() => {
				notification.style.opacity = '0';
				setTimeout(() => {
					if (notification.parentNode) {
						notification.parentNode.removeChild(notification);
					}
					if (this._activeNotification === notification) {
						this._activeNotification = null;
					}
				}, 300);
			}, 2000);
		}

		// Âä†ËΩΩÂ∑≤‰øùÂ≠òÁöÑÁä∂ÊÄÅ
		loadSavedStates() {
			this.stateManager.loadFromMemory();

			// ÂàÜÂ±ÇÂ∫îÁî®Â∑≤‰øùÂ≠òÁöÑÁä∂ÊÄÅÔºà‰ªéÈ´òÁ∫ßÂà´Âà∞‰ΩéÁ∫ßÂà´Ôºâ
			for (let level = 1; level <= 6; level++) {
				this.applyStatesForLevel(level);
			}
		}

		applyStatesForLevel(level) {
			const headers = this.getAllHeaders().filter(h =>
				this.stateManager.getHeaderLevel(h) === level
			);

			headers.forEach(header => {
				const headerKey = this.stateManager.generateHeaderKey(header);
				const savedState = this.stateManager.getHeaderState(headerKey);

				if (savedState && savedState.isCollapsed) {
					Logger.log(`[GHCM] ÊÅ¢Â§ç H${level} Ê†áÈ¢òÁä∂ÊÄÅ:`, header.textContent.trim());
					header.classList.add(CONFIG.classes.collapsed);
					this.updateAriaExpanded(header);
					this.updateContent(header, true);
			}
		});
	}

		applyStateToElement(headerKey, state) {
			// ‰øùÁïôÂéüÊñπÊ≥ï‰Ωú‰∏∫Â§áÁî®
			const headers = this.getAllHeaders();
			headers.forEach(header => {
				const currentKey = this.stateManager.generateHeaderKey(header);
				if (currentKey === headerKey && state.isCollapsed) {
					header.classList.add(CONFIG.classes.collapsed);
					this.updateAriaExpanded(header);
					this.updateContent(header, true);
				}
			});
		}

		// ‰ª£ÁêÜÁõÆÂΩïÂíåÊêúÁ¥¢ÂäüËÉΩ
		toggleToc() {
			if (this.tocGenerator) {
				this.tocGenerator.toggle();
			}
		}

		toggleSearch() {
			if (this.searchManager) {
				this.searchManager.toggle();
			}
		}

		// Ê£ÄÊü•Ê†áÈ¢òÊòØÂê¶ÊúâÂÜÖÂÆπ
		markEmptyHeaders() {
			CONFIG.selectors.markdownContainers.forEach(containerSelector => {
				const selector = DOMUtils.getScopedHeadingSelector(containerSelector, { includeWrapper: true });
				if (!selector) return;

				DOMUtils.$$(selector).forEach(header => {
					const level = this.stateManager.getHeaderLevel(header);
					const elements = this.getContentElements(header, level);

					if (elements.length === 0) {
						header.classList.add(CONFIG.classes.noContent);
					} else {
						header.classList.remove(CONFIG.classes.noContent);
					}
				});
			});
		}
	}

	// ‰∫ã‰ª∂ÁÆ°ÁêÜÂô®
	class EventManager {
	constructor(collapseManager) {
		this.collapseManager = collapseManager;
		this.hoverHeader = null;
		this.setupEventListeners();
	}

		setupEventListeners() {
			// ÁÇπÂáª‰∫ã‰ª∂
			document.addEventListener("click", this.handleClick.bind(this), true);
			// Hover È´ò‰∫Æ
			this._hoverHandler = this.handleHover.bind(this);
			this._hoverLeaveHandler = this.handleHoverLeave.bind(this);
			document.addEventListener('mouseover', this._hoverHandler, true);
			document.addEventListener('mouseout', this._hoverLeaveHandler, true);

			// Hash ÂèòÂåñ‰∫ã‰ª∂
			window.addEventListener("hashchange", this.handleHashChange.bind(this));

			// DOM ÂèòÂåñÁõëÂê¨ÔºàÂ¶ÇÊûúÊúâÂÖ∂‰ªñËÑöÊú¨‰øÆÊîπDOMÔºâ
			if (window.ghmo) {
				window.addEventListener("ghmo:dom", this.handleDOMChange.bind(this));
			}

			// GitHub ÂØºËà™‰∫ã‰ª∂ÔºàPJAX/TurboÔºâ
			document.addEventListener("pjax:end", this.handleNavigation.bind(this));
			document.addEventListener("turbo:load", this.handleNavigation.bind(this));
			document.addEventListener("turbo:render", this.handleNavigation.bind(this));
			window.addEventListener("pageshow", this.handleNavigation.bind(this));

			// È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéÂàùÂßãÂåñ
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', this.handleDOMChange.bind(this));
			} else {
				setTimeout(() => this.handleDOMChange(), 200);
			}
		}

		handleClick(event) {
			let target = event.target;

			// ‰ªÖÂ§ÑÁêÜÂ∑¶ÈîÆ
			if (event.button !== 0) return;

			// ÊñáÊú¨ÈÄâÊã©Êó∂‰∏çËß¶Âèë
			try {
				const sel = window.getSelection?.();
				if (sel && sel.toString && sel.toString().trim().length > 0) return;
			} catch {}

			// Â§ÑÁêÜSVGÁÇπÂáª
			if (target.nodeName === "path") {
				target = target.closest("svg");
			}

			// Ë∑≥ËøáÊéíÈô§ÁöÑÂÖÉÁ¥†‰∏éËá™Ë∫´UI
			if (!target || this.shouldSkipElement(target) || target.closest('.ghcm-menu-container, .ghcm-search-container, .ghcm-toc-container, .ghcm-menu-button')) {
				return;
			}

			// Êü•ÊâæÊúÄËøëÁöÑÊ†áÈ¢òÂÖÉÁ¥†
			const header = target.closest(DOMUtils.getHeadingSelector());

			if (header && DOMUtils.isHeader(header) && DOMUtils.isInMarkdown(header)) {
				// ‰ªÖÂú®ÁúüÊ≠£ÊâßË°åÊäòÂè†Êó∂Â§ÑÁêÜÔºåÈÅøÂÖçÂπ≤Êâ∞ÈªòËÆ§ÈìæÊé•Á≠âË°å‰∏∫
				Logger.log("[GHCM] Header clicked:", header);
			this.collapseManager.toggle(header, event.shiftKey);
		}
			}

		handleHover(event) {
			const header = event.target.closest(DOMUtils.getHeadingSelector());
			if (!header || !DOMUtils.isHeader(header)) return;
			if (this.hoverHeader === header) return;
			try {
				if (this.hoverHeader) {
					this.hoverHeader.classList.remove(CONFIG.classes.hoverHeading);
				}
				header.classList.add(CONFIG.classes.hoverHeading);
				this.hoverHeader = header;
			} catch {}
		}

		handleHoverLeave(event) {
			const header = event.target.closest(DOMUtils.getHeadingSelector());
			if (!header || !DOMUtils.isHeader(header)) return;
			const related = event.relatedTarget;
			if (related && (related === header || related.closest?.(DOMUtils.getHeadingSelector()) === header)) {
				return;
			}
			if (this.hoverHeader === header) {
				header.classList.remove(CONFIG.classes.hoverHeading);
				this.hoverHeader = null;
			}
		}

		shouldSkipElement(element) {
			const nodeName = element.nodeName?.toLowerCase();
			// Ë°®Âçï/ÂèØÁºñËæëÂå∫ÂüüÂÜÖÁöÑ‰∫§‰∫í‰∏çËß¶ÂèëÊäòÂè†
			try {
				if (element.closest('input, textarea, select, [contenteditable=""], [contenteditable="true"], [role="textbox"]')) {
					return true;
				}
			} catch {}

			return CONFIG.selectors.excludeClicks.some(selector => {
				if (selector.startsWith('.')) {
					return element.classList.contains(selector.slice(1));
				}
				return nodeName === selector;
			});
		}

		handleHashChange() {
			const hash = window.location.hash.replace(/#/, "");
			if (hash) {
				this.openHashTarget(hash);
			}
		}

		handleDOMChange() {
			DOMUtils.invalidateHeadingCache();
			try { this.collapseManager.searchManager?.invalidateIndex?.(); } catch {}
			try { this.collapseManager.bookmarkManager?.applyBookmarks?.(); } catch {}
			// ÈáçÊñ∞Ê†áËÆ∞Á©∫Ê†áÈ¢ò
			this.collapseManager.markEmptyHeaders();

			// Â§ÑÁêÜÂΩìÂâçhash
			this.handleHashChange();
			try {
				const active = this.collapseManager.getActiveHeaderElement();
				if (active) this.collapseManager.setActiveHeading(active);
			} catch {}
		}

		handleNavigation() {
			DOMUtils.invalidateHeadingCache();
			try { this.collapseManager.searchManager?.invalidateIndex?.(); } catch {}
			try { this.collapseManager.bookmarkManager?.applyBookmarks?.(); } catch {}
			// ÂÖàÊ∏ÖÁêÜ‰ªª‰ΩïÊåÇËµ∑ÁöÑÂä®Áîª/ÂÆöÊó∂Âô®
			try { this.collapseManager.clearAllAnimations(); } catch {}
			// Êõ¥Êñ∞È°µÈù¢ÈîÆÔºåÈÄÇÈÖçÂçïÈ°µÂØºËà™
			try { this.collapseManager.stateManager.updatePageKey(); } catch (e) {}
			// ÈáçÂª∫Ê†áËÆ∞Âπ∂ÊåâÈúÄÊÅ¢Â§çÁä∂ÊÄÅ
			this.handleDOMChange();
			if (CONFIG.memory.enabled) {
				setTimeout(() => {
					try { this.collapseManager.loadSavedStates(); } catch (e) {}
				}, 300);
			}
		}

		openHashTarget(id) {
			// Â∞ùËØïÂ§öÁßçIDÊ†ºÂºè
			const possibleSelectors = [
				`#user-content-${id}`,
				`#${id}`,
				`[id="${id}"]`
			];

			let targetElement = null;
			for (const selector of possibleSelectors) {
				targetElement = DOMUtils.$(selector);
				if (targetElement) break;
			}

			if (!targetElement) return;

			// Êü•ÊâæÂØπÂ∫îÁöÑÊ†áÈ¢ò
			let header = targetElement;
			if (!DOMUtils.isHeader(header)) {
				header = targetElement.closest(DOMUtils.getHeadingSelector());
			}

			if (header && DOMUtils.isHeader(header)) {
				this.collapseManager.expandToHeader(header, { scroll: false, setActive: false });
				this.collapseManager.scrollToElement(header);
				this.collapseManager.setActiveHeading(header);
			}
		}
	}

	// ‰∏ªÂ∫îÁî®Á±ª
	class GitHubCollapseMarkdown {
		constructor() {
			this.stateManager = new StateManager();
			this.styleManager = new StyleManager();
			this.collapseManager = new CollapseManager(this.stateManager);
			this.tocGenerator = new TocGenerator();
			this.searchManager = new SearchManager(this.collapseManager);
			this.bookmarkManager = new BookmarkManager(this);
			this.menuManager = new MenuManager(this);
			this.helpModal = new HelpModal(this);
			this.hotkeyManager = new HotkeyManager(this.collapseManager);
			this.hotkeyManager.setApp(this);
			this.eventManager = new EventManager(this.collapseManager);

			// Â∞ÜÈôÑÂä†ÂäüËÉΩÂÖ≥ËÅîÂà∞ÊäòÂè†ÁÆ°ÁêÜÂô®
			this.collapseManager.tocGenerator = this.tocGenerator;
			this.collapseManager.searchManager = this.searchManager;
			this.collapseManager.menuManager = this.menuManager;
			this.collapseManager.bookmarkManager = this.bookmarkManager;
			this.tocGenerator.collapseManager = this.collapseManager;

			this.init();
		}

		init() {
			const performanceMode = GM_getValue("ghcm-performance-mode", false);
			const memoryEnabled = CONFIG.memory.enabled;
			const hotkeysEnabled = CONFIG.hotkeys.enabled;

			const animationStatus = (CONFIG.animation.maxAnimatedElements === 0) ? "ÊÄßËÉΩÊ®°Âºè (Êó†Âä®Áîª)" : "Ê†áÂáÜÊ®°Âºè (ÊúâÂä®Áîª)";

			Logger.log(`[GHCM] Initializing GitHub Collapse Markdown (Optimized v3.2.4) - ${animationStatus}`);
			Logger.log(`[GHCM] üß† Êô∫ËÉΩÂµåÂ•óÁä∂ÊÄÅÁÆ°ÁêÜ: ÂêØÁî®`);
			Logger.log(`[GHCM] üé® Áé∞‰ª£GUIÁïåÈù¢: ÂêØÁî®`);
			Logger.log(`[GHCM] Âä®ÁîªÈòàÂÄº: ${CONFIG.animation.maxAnimatedElements} ‰∏™ÂÖÉÁ¥†`);
			Logger.log(`[GHCM] Áä∂ÊÄÅËÆ∞ÂøÜ: ${memoryEnabled ? "ÂêØÁî®" : "Á¶ÅÁî®"}`);
			Logger.log(`[GHCM] Âø´Êç∑ÈîÆ: ${hotkeysEnabled ? "ÂêØÁî®" : "Á¶ÅÁî®"}`);

			// Ê∑ªÂä†ËèúÂçïÂëΩ‰ª§
			this.setupMenuCommands();

			// ÂàùÂßãÊ£ÄÊü•ÂíåÁä∂ÊÄÅÂä†ËΩΩ
				setTimeout(() => {
				this.collapseManager.markEmptyHeaders();

				// Âä†ËΩΩÂ∑≤‰øùÂ≠òÁöÑÊäòÂè†Áä∂ÊÄÅ
				if (memoryEnabled) {
					this.collapseManager.loadSavedStates();
				}
				// ÂêåÊ≠•ÊâÄÊúâÊ†áÈ¢òÁöÑÊó†ÈöúÁ¢çÁä∂ÊÄÅ
				this.collapseManager.syncAriaExpandedForAll();
				this.bookmarkManager.applyBookmarks();
				}, 500);

			// ÁõëÂê¨ÊäòÂè†Áä∂ÊÄÅÂèòÂåñÔºåÊõ¥Êñ∞ÁõÆÂΩïÊòæÁ§∫ÂíåËèúÂçïÁªüËÆ°
			document.addEventListener('ghcm:toggle-complete', () => {
				if (this.tocGenerator.isVisible) {
					setTimeout(() => {
						this.tocGenerator.refreshTocStates();
					}, CONFIG.animation.duration + 150);
				}
				// Â¶ÇÊûúËèúÂçïÊâìÂºÄÔºåÂà∑Êñ∞ÁªüËÆ°‰ø°ÊÅØ
				if (this.menuManager.isVisible) {
					setTimeout(() => {
						this.menuManager.refreshMenu();
					}, CONFIG.animation.duration + 150);
				}
			});
		}

		setupMenuCommands() {
			try {
				// === Âü∫Á°ÄÊìç‰Ωú ===
				GM_registerMenuCommand("üìÅ ÊäòÂè†ÊâÄÊúâÊ†áÈ¢ò", () => {
					this.collapseManager.collapseAll();
				});

				GM_registerMenuCommand("üìÇ Â±ïÂºÄÊâÄÊúâÊ†áÈ¢ò", () => {
					this.collapseManager.expandAll();
				});

				GM_registerMenuCommand("üîÑ Êô∫ËÉΩÂàáÊç¢", () => {
					this.collapseManager.toggleAll();
				});

				// === Â∑•ÂÖ∑ÂäüËÉΩ ===
				GM_registerMenuCommand("üìë ÁõÆÂΩïÂØºËà™", () => {
					this.tocGenerator.toggle();
				});

					GM_registerMenuCommand("üîç ÊêúÁ¥¢Ê†áÈ¢ò", () => {
						this.searchManager.toggle();
					});

					GM_registerMenuCommand("‚≠ê Êî∂ËóèÂΩìÂâçÊ†áÈ¢ò", () => {
						this.bookmarkManager.addBookmarkFromViewport();
					});

					GM_registerMenuCommand("üóÇÔ∏è Ê∏ÖÁ©∫Êú¨È°µ‰π¶Á≠æ", () => {
						this.bookmarkManager.clearPageBookmarks();
					});

				// === ËÆæÁΩÆÈÄâÈ°π ===
				GM_registerMenuCommand("‚ö° ÊÄßËÉΩÊ®°Âºè", () => {
					this.togglePerformanceMode();
				});

				GM_registerMenuCommand("üíæ Áä∂ÊÄÅËÆ∞ÂøÜ", () => {
					this.toggleMemory();
				});

				GM_registerMenuCommand("‚å®Ô∏è Âø´Êç∑ÈîÆ", () => {
					this.toggleHotkeys();
				});

				GM_registerMenuCommand("üêõ Ë∞ÉËØïÊ®°Âºè", () => {
					this.toggleDebug();
				});

				// === ÈáçÁΩÆÂäüËÉΩ ===
				GM_registerMenuCommand("üîÑ ÈáçÁΩÆÊäòÂè†Áä∂ÊÄÅ", () => {
					this.resetAllStates();
				});

				GM_registerMenuCommand("üóëÔ∏è Ê∏ÖÈô§ËÆ∞ÂøÜÊï∞ÊçÆ", () => {
					this.clearAllMemory();
				});

				// === ‰ø°ÊÅØÂ∏ÆÂä© ===
				GM_registerMenuCommand("üìä ÂΩìÂâçÁªüËÆ°", () => {
					this.showStatistics();
				});

				GM_registerMenuCommand("‚ÑπÔ∏è ‰ΩøÁî®ËØ¥Êòé", () => {
					this.showHotkeyHelp();
				});

			} catch (e) {
				Logger.warn("[GHCM] ËèúÂçïÂäüËÉΩ‰∏çÂèØÁî®:", e);
			}
		}

		toggleMemory() {
			const newState = !CONFIG.memory.enabled;
			CONFIG.memory.enabled = newState;
			GM_setValue("ghcm-memory-enabled", newState);

			const status = newState ? "ÂêØÁî®" : "Á¶ÅÁî®";
			Logger.log(`[GHCM] Áä∂ÊÄÅËÆ∞ÂøÜÂ∑≤${status}`);
			this.collapseManager.showNotification(`üíæ Áä∂ÊÄÅËÆ∞ÂøÜÂ∑≤${status}`);
			if (newState) {
				this.stateManager.scheduleSave({ force: true });
			} else {
				this.stateManager.cancelScheduledSave();
			}
		}

		toggleHotkeys() {
			const newState = !CONFIG.hotkeys.enabled;
			CONFIG.hotkeys.enabled = newState;
			GM_setValue("ghcm-hotkeys-enabled", newState);

			const status = newState ? "ÂêØÁî®" : "Á¶ÅÁî®";
			Logger.log(`[GHCM] Âø´Êç∑ÈîÆÂ∑≤${status}`);
			this.collapseManager.showNotification(`‚å®Ô∏è Âø´Êç∑ÈîÆÂ∑≤${status}`);

			if (newState) {
				// ÈáçÊñ∞ÁªëÂÆöÂø´Êç∑ÈîÆ
				this.hotkeyManager.setupHotkeys();
			} else {
				// Ëß£Èô§ÁªëÂÆöÔºåÈÅøÂÖçÈáçÂ§ç‰∏éÂ§öÊ¨°Ëß¶Âèë
				this.hotkeyManager.teardownHotkeys();
			}
		}

		toggleVimNav() {
			const newState = !CONFIG.hotkeys.navEnabled;
			CONFIG.hotkeys.navEnabled = newState;
			GM_setValue('ghcm-nav-enabled', newState);

			const status = newState ? 'ÂêØÁî®' : 'Á¶ÅÁî®';
			Logger.log(`[GHCM] Vim ÂØºËà™ÁÉ≠ÈîÆÂ∑≤${status}`);
			this.collapseManager.showNotification(`üß≠ Vim ÂØºËà™ÁÉ≠ÈîÆÂ∑≤${status}`);
		}

		toggleShowLevelNumber() {
			CONFIG.ui.showLevelNumber = !CONFIG.ui.showLevelNumber;
			GM_setValue('ghcm-show-level-number', CONFIG.ui.showLevelNumber);
			try { this.styleManager.updateArrowContentOverride(); } catch {}
			this.collapseManager.showNotification(CONFIG.ui.showLevelNumber ? 'üî¢ ÊòæÁ§∫Á∫ßÂà´Êï∞Â≠ó' : 'üîΩ ‰ªÖÊòæÁ§∫ÁÆ≠Â§¥');
		}

		setColorScheme(name) {
			const scheme = CONFIG.colorSchemes[name];
			if (!scheme) {
				this.collapseManager.showNotification('‚ö†Ô∏è Êú™ÊâæÂà∞ÊåáÂÆöÁöÑÈÖçËâ≤ÊñπÊ°à');
				return;
			}
			this.styleManager.updateColors(scheme);
			if (name === 'custom') {
				this.collapseManager.showNotification('üé® Â∑≤Â∫îÁî®Ëá™ÂÆö‰πâÈÖçËâ≤');
			} else {
				this.collapseManager.showNotification(`üé® Â∑≤Â∫îÁî®ÈÖçËâ≤Ôºö${name}`);
			}
		}

		promptCustomColors() {
			const current = (CONFIG.colorSchemes.custom || CONFIG.colors).join(', ');
			const input = prompt('ËØ∑ËæìÂÖ•Êñ∞ÁöÑÈÖçËâ≤ÔºàÂèØÁî®ÈÄóÂè∑ÊàñÁ©∫Ê†ºÂàÜÈöîÔºåËá≥Â∞ë 1 ‰∏™Ëâ≤ÂÄºÔºâ', current);
			if (input === null) return;
			const parts = input.split(/[\s,]+/).map(part => part.trim()).filter(Boolean);
			if (!parts.length) {
				this.collapseManager.showNotification('‚ö†Ô∏è Êú™ËæìÂÖ•ÊúâÊïàÁöÑÈ¢úËâ≤');
				return;
			}
			while (parts.length < 6) {
				parts.push(parts[parts.length - 1] || parts[0]);
			}
			const colors = parts.slice(0, 6);
			CONFIG.colorSchemes.custom = colors;
			GM_setValue('ghcm-custom-colors', colors);
			this.setColorScheme('custom');
			this.menuManager.refreshMenu();
		}

		promptArrowSize() {
			const current = CONFIG.ui.arrowSize || '0.8em';
			const input = prompt('ËÆæÁΩÆÁÆ≠Â§¥Â≠óÂè∑ÔºàÂ¶Ç 0.8em„ÄÅ12pxÔºâ', current);
			if (input === null) return;
			const value = input.trim();
			if (!value) {
				this.collapseManager.showNotification('‚ö†Ô∏è ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÂ∞∫ÂØ∏');
				return;
			}
			CONFIG.ui.arrowSize = value;
			this.styleManager.updateArrowSize(value);
			this.collapseManager.showNotification(`üî† Â∑≤Êõ¥Êñ∞ÁÆ≠Â§¥Â§ßÂ∞èÔºö${value}`);
			this.menuManager.refreshMenu();
		}

		toggleDebug() {
			const newState = !CONFIG.debug;
			CONFIG.debug = newState;
			GM_setValue("ghcm-debug-mode", newState);

			const status = newState ? "ÂêØÁî®" : "Á¶ÅÁî®";
			Logger.log(`[GHCM] Ë∞ÉËØïÊ®°ÂºèÂ∑≤${status}`);
			this.collapseManager.showNotification(`üêõ Ë∞ÉËØïÊ®°ÂºèÂ∑≤${status}`);
		}

		togglePerformanceMode() {
			const isPerformanceMode = CONFIG.animation.maxAnimatedElements === 0;
			const newState = !isPerformanceMode;

			if (newState) {
				// ÂêØÁî®ÊÄßËÉΩÊ®°ÂºèÔºàÁ¶ÅÁî®Âä®ÁîªÔºâ
				CONFIG.animation.maxAnimatedElements = 0;
				GM_setValue("ghcm-performance-mode", true);
				Logger.log("[GHCM] Â∑≤ÂêØÁî®ÊÄßËÉΩÊ®°Âºè - Âä®ÁîªÂ∑≤Á¶ÅÁî®");
				this.collapseManager.showNotification("‚ö° ÊÄßËÉΩÊ®°ÂºèÂ∑≤ÂêØÁî®");
			} else {
				// Á¶ÅÁî®ÊÄßËÉΩÊ®°ÂºèÔºàÂêØÁî®Âä®ÁîªÔºâ
				CONFIG.animation.maxAnimatedElements = 20;
				GM_setValue("ghcm-performance-mode", false);
				Logger.log("[GHCM] Â∑≤Á¶ÅÁî®ÊÄßËÉΩÊ®°Âºè - Âä®ÁîªÂ∑≤ÂêØÁî®");
				this.collapseManager.showNotification("üé¨ Âä®ÁîªÊïàÊûúÂ∑≤ÂêØÁî®");
			}
		}

		clearAllMemory() {
			if (confirm("Á°ÆÂÆöË¶ÅÊ∏ÖÈô§ÊâÄÊúâÈ°µÈù¢ÁöÑÊäòÂè†Áä∂ÊÄÅËÆ∞ÂøÜÂêóÔºü")) {
				GM_setValue(CONFIG.memory.key, {});
				this.stateManager.clear();
				Logger.log("[GHCM] Â∑≤Ê∏ÖÈô§ÊâÄÊúâËÆ∞ÂøÜÊï∞ÊçÆ");
				this.collapseManager.showNotification("üóëÔ∏è Â∑≤Ê∏ÖÈô§ÊâÄÊúâËÆ∞ÂøÜÊï∞ÊçÆ");
			}
		}

		showHotkeyHelp() {
			this.helpModal?.show();
		}

		showStatistics() {
			const headers = this.collapseManager.getAllHeaders();
			const collapsed = headers.filter(h => h.classList.contains(CONFIG.classes.collapsed));
			const visible = headers.filter(h =>
				!h.classList.contains(CONFIG.classes.collapsed) &&
				!h.classList.contains(CONFIG.classes.noContent)
			);

			const levelStats = {};
			for (let i = 1; i <= 6; i++) {
				const levelHeaders = headers.filter(h =>
					this.stateManager.getHeaderLevel(h) === i
				);
				if (levelHeaders.length > 0) {
					levelStats[`H${i}`] = {
						total: levelHeaders.length,
						collapsed: levelHeaders.filter(h => h.classList.contains(CONFIG.classes.collapsed)).length
					};
				}
			}

			const levelStatsText = Object.entries(levelStats)
				.map(([level, stats]) =>
					`${level}: ${stats.total}‰∏™ (${stats.collapsed}‰∏™Â∑≤ÊäòÂè†)`
				).join(', ');

			const statsContent = `
üìä ÂΩìÂâçÈ°µÈù¢ÁªüËÆ°

üìù Ê†áÈ¢òÊ¶ÇÂÜµÔºö
‚Ä¢ ÊÄªËÆ°Ôºö${headers.length} ‰∏™Ê†áÈ¢ò
‚Ä¢ Â∑≤ÊäòÂè†Ôºö${collapsed.length} ‰∏™
‚Ä¢ ÂèØËßÅÔºö${visible.length} ‰∏™

üìã Á∫ßÂà´ÂàÜÂ∏ÉÔºö${levelStatsText || 'Êó†Ê†áÈ¢ò'}

‚öôÔ∏è ÂäüËÉΩÁä∂ÊÄÅÔºö
‚Ä¢ ÊÄßËÉΩÊ®°ÂºèÔºö${CONFIG.animation.maxAnimatedElements === 0 ? 'üü¢ ÂêØÁî®' : 'üî¥ Á¶ÅÁî®'}
‚Ä¢ Áä∂ÊÄÅËÆ∞ÂøÜÔºö${CONFIG.memory.enabled ? 'üü¢ ÂêØÁî®' : 'üî¥ Á¶ÅÁî®'}
‚Ä¢ Âø´Êç∑ÈîÆÔºö${CONFIG.hotkeys.enabled ? 'üü¢ ÂêØÁî®' : 'üî¥ Á¶ÅÁî®'}
			`.trim();

			alert(statsContent);
		}

		resetAllStates() {
			// ÁßªÈô§ÊâÄÊúâÊäòÂè†Áä∂ÊÄÅ
			DOMUtils.$$(".ghcm-collapsed").forEach(element => {
				element.classList.remove(CONFIG.classes.collapsed);
				try { element.setAttribute('aria-expanded', 'true'); } catch {}
			});

			// ÊòæÁ§∫ÊâÄÊúâÈöêËóèÁöÑÂÜÖÂÆπ
			DOMUtils.$$(".ghcm-hidden-by-parent").forEach(element => {
				element.classList.remove(CONFIG.classes.hiddenByParent);
				element.style.removeProperty('display');
				element.style.opacity = '';
				element.style.transform = '';
			});

			// Ê∏ÖÁ©∫Áä∂ÊÄÅ
			this.stateManager.clear();

			Logger.log("[GHCM] Â∑≤ÈáçÁΩÆÊâÄÊúâÊäòÂè†Áä∂ÊÄÅ");
		}
	}

	// ÂêØÂä®Â∫îÁî®
	window.ghcmInstance = new GitHubCollapseMarkdown();

})();
